# 加密算法

```c
u->struct_p[1];  /* device_id */
u->struct_p[2] = key_id;
u->struct_p[3] = UM_UNENCRY_0 | UM_ENCRY_SHA256_2 | UM_ENCRY_AES256_5 | UM_DECRY_7; 
if(!passw_hidden_flag)
	u->struct_p[3] |= UM_UNHIDE_UNENCRY_PWD;
u->struct_p[4] = RIP_AUTH_PWD_SIM; /* RIP_AUTH_PWD_MD5或RIP_AUTH_PWD_DYNC_MD5或RIP_AUTH_PWD_DYNC_SHA1 */
u->struct_p[5] = (unsigned long)enpassw;  /*用于保存被调函数获取的值*/
u->struct_p[6] = 0; 					  /*用于后续保存um加密类型对应的标志位*/

if(!vty_startup_config_complete || !redn_msu_is_active())
	u->struct_p[3] |= UM_DECRY_7 | UM_DECRY_SHA256_6 | UM_DECRY_AES256_9;

u->cmd_mskbits = u->struct_p[3];
mode = u->struct_p[3] - u->cmd_mskbits;
if (mode == UM_UNHIDE_UNENCRY_PWD)
{	/*只有在非韩国模式下，才可能进入此分支，用于命令输入完毕以后，附加? ，会输出<cr>提示*/
	rc = cmdend(argc - 1, argv + 1, u);
	if (rc != 0) 
	{
		return rc;
	}
		
	/* 表示UM模式0下， CLI输入时，外层命令带掩码UM_UNHIDE_UNENCRY的不是子命令，而是命令参数，所以这里需要
	调整argc和argv*/
	argc++;
	argv--;
}
else
{
	/*暂存UM的类型，可能用于没有配置service password-encryption, service password-hidden时，
	此时在端口下配置ip rip md5 1 md5 7或者0 password的情况下做进一步处理*/
	u->struct_p[6] = mode;
}
```



## MD5

```c
// authen_tail->key.md5: char [16]
rt_md5_cksum((byte *)rip_recv_buffer, packet_len, packet_len, authen_tail->key.md5, (uint32*)0);
```

```c
#define	MD5_GET(x, cp) \
    do { \
	register uint32 Xtmp; \
	Xtmp = (uint32)(*(cp)++); \
	Xtmp |= ((uint32)(*(cp)++)) << 8; \
	Xtmp |= ((uint32)(*(cp)++)) << 16; \
	Xtmp |= ((uint32)(*(cp)++)) << 24; \
	(x) = Xtmp; \
    } while (0)
    
#define	MD5_PUT(x, cp) \
    do { \
	register uint32 Xtmp = (x); \
	*(cp)++ = (byte) Xtmp; \
	*(cp)++ = (byte) (Xtmp >> 8); \
	*(cp)++ = (byte) (Xtmp >> 16); \
	*(cp)++ = (byte) (Xtmp >> 24); \
    } while (0)    
```

```c
void rt_md5_cksum(void *data, unsigned int datalen, unsigned int totallen, void *digest, uint32 *init)
{
	register byte  *dp;
	MD5_CTX         context;

	context.count[0] = context.count[1] = 0;
	if(init) {
		context.state[0] = init[0];
		context.state[1] = init[1];
		context.state[2] = init[2];
		context.state[3] = init[3];
	} else {
		context.state[0] = MD5_A_INIT;
		context.state[1] = MD5_B_INIT;
		context.state[2] = MD5_C_INIT;
		context.state[3] = MD5_D_INIT;
	}

	md5_cksum_block(data, datalen, totallen, 0, context.state);

	dp = (byte *) digest;
	MD5_PUT(context.state[0], dp);   //state：unsigned long 
	MD5_PUT(context.state[1], dp);
	MD5_PUT(context.state[2], dp);
	MD5_PUT(context.state[3], dp);
}
```

```c
static void md5_cksum_block(void *data, unsigned int datalen, unsigned int totallen, int incomplete,
							uint32 *results)
{
	register uint32 a, b, c, d;
	int             alldone = 0;

	/*
	 * Fetch the initial values of the accumulators
	 */
	a = results[0];
	b = results[1];
	c = results[2];
	d = results[3];

	/*
	 * Work on the data first
	 */
	{
        // unsigned char *dp;
		register byte  *dp;
		register unsigned int dlen;
		register uint32 *xp;
		uint32          x[64];

		/*
		 * Initialize data pointer/length
		 */
		dp = (byte *) data;
		dlen = datalen;

/**
#define	MD5_GET(x, cp) \    小端序
  do { \
	register uint32 Xtmp; \
	Xtmp = (uint32)(*(cp)++); \
	Xtmp |= ((uint32)(*(cp)++)) << 8; \
	Xtmp |= ((uint32)(*(cp)++)) << 16; \
	Xtmp |= ((uint32)(*(cp)++)) << 24; \
	(x) = Xtmp; \
  } while (0)
*/
		while(dlen) {
			xp = x;
			if(dlen >= 64) {
                // 32Byte => 4个8bit => 8个16进制数
				MD5_GET(*xp, dp);
				xp++;
				MD5_GET(*xp, dp);
				xp++;
				MD5_GET(*xp, dp);
				xp++;
				MD5_GET(*xp, dp);
				xp++;
				MD5_GET(*xp, dp);
				xp++;
				MD5_GET(*xp, dp);
				xp++;
				MD5_GET(*xp, dp);
				xp++;
				MD5_GET(*xp, dp);
				xp++;
				MD5_GET(*xp, dp);
				xp++;
				MD5_GET(*xp, dp);
				xp++;
				MD5_GET(*xp, dp);
				xp++;
				MD5_GET(*xp, dp);
				xp++;
				MD5_GET(*xp, dp);
				xp++;
				MD5_GET(*xp, dp);
				xp++;
				MD5_GET(*xp, dp);
				xp++;
				MD5_GET(*xp, dp);
				dlen -= 64;
			} else {
				assert(!incomplete);
				switch (dlen >> 2) {
                // 有多少个完整的4字节
				case 15:
					MD5_GET(*xp, dp);
					xp++;
				case 14:
					MD5_GET(*xp, dp);
					xp++;
				case 13:
					MD5_GET(*xp, dp);
					xp++;
				case 12:
					MD5_GET(*xp, dp);
					xp++;
				case 11:
					MD5_GET(*xp, dp);
					xp++;
				case 10:
					MD5_GET(*xp, dp);
					xp++;
				case 9:
					MD5_GET(*xp, dp);
					xp++;
				case 8:
					MD5_GET(*xp, dp);
					xp++;
				case 7:
					MD5_GET(*xp, dp);
					xp++;
				case 6:
					MD5_GET(*xp, dp);
					xp++;
				case 5:
					MD5_GET(*xp, dp);
					xp++;
				case 4:
					MD5_GET(*xp, dp);
					xp++;
				case 3:
					MD5_GET(*xp, dp);
					xp++;
				case 2:
					MD5_GET(*xp, dp);
					xp++;
				case 1:
					MD5_GET(*xp, dp);
					xp++;
				default:
					break;
				}

				switch (dlen & 0x3) { // 0011
				case 3: // 余3位... 组成4字节 1000 0000 0000 0000 0000 0000 0000 0000
					*xp = (uint32) 0x80000000 | (uint32) (*dp++);
					*xp |= (uint32) (*dp++) << 8;
					*xp++ |= (uint32) (*dp++) << 16;
					break;
				case 2: // 1000
					*xp = (uint32) 0x800000 | (uint32) (*dp++);
					*xp++ |= (uint32) (*dp++) << 8;
					break;
				case 1:
					*xp++ = (uint32) 0x8000 | (uint32) (*dp++);
					break;
				default:
					*xp++ = (uint32) 0x80;
					break;
				}

				if(xp >= &(x[15])) {
					if(xp == &(x[15])) {
						*xp = 0;
					}
				} else {
					while(xp < &(x[14])) {
						*xp++ = 0;
					}
					*xp++ = (((uint32) (totallen)) << 3) & 0xffffffff;
					*xp = (uint32) ((totallen >> 29) & 0xffffffff);
					alldone = 1;
				}
				dlen = 0;
			}

			/*
			 * Done, x contains the block to screw around with.  Run the
			 * MD5 algorithm over the block.  Initialize the variables
			 * we'll be using.
			 */
			xp = x;

			/* round 1 */
			MD5_OP1(a, b, c, d, xp[0], 7, 0xd76aa478);	/* 0 */
			MD5_OP1(d, a, b, c, xp[1], 12, 0xe8c7b756);	/* 1 */
			MD5_OP1(c, d, a, b, xp[2], 17, 0x242070db);	/* 2 */
			MD5_OP1(b, c, d, a, xp[3], 22, 0xc1bdceee);	/* 3 */
			MD5_OP1(a, b, c, d, xp[4], 7, 0xf57c0faf);	/* 4 */
			MD5_OP1(d, a, b, c, xp[5], 12, 0x4787c62a);	/* 5 */
			MD5_OP1(c, d, a, b, xp[6], 17, 0xa8304613);	/* 6 */
			MD5_OP1(b, c, d, a, xp[7], 22, 0xfd469501);	/* 7 */
			MD5_OP1(a, b, c, d, xp[8], 7, 0x698098d8);	/* 8 */
			MD5_OP1(d, a, b, c, xp[9], 12, 0x8b44f7af);	/* 9 */
			MD5_OP1(c, d, a, b, xp[10], 17, 0xffff5bb1);	/* 10 */
			MD5_OP1(b, c, d, a, xp[11], 22, 0x895cd7be);	/* 11 */
			MD5_OP1(a, b, c, d, xp[12], 7, 0x6b901122);	/* 12 */
			MD5_OP1(d, a, b, c, xp[13], 12, 0xfd987193);	/* 13 */
			MD5_OP1(c, d, a, b, xp[14], 17, 0xa679438e);	/* 14 */
			MD5_OP1(b, c, d, a, xp[15], 22, 0x49b40821);	/* 15 */

			/* round 2 */
			MD5_OP2(a, b, c, d, xp[1], 5, 0xf61e2562);	/* 16 */
			MD5_OP2(d, a, b, c, xp[6], 9, 0xc040b340);	/* 17 */
			MD5_OP2(c, d, a, b, xp[11], 14, 0x265e5a51);	/* 18 */
			MD5_OP2(b, c, d, a, xp[0], 20, 0xe9b6c7aa);	/* 19 */
			MD5_OP2(a, b, c, d, xp[5], 5, 0xd62f105d);	/* 20 */
			MD5_OP2(d, a, b, c, xp[10], 9, 0x02441453);	/* 21 */
			MD5_OP2(c, d, a, b, xp[15], 14, 0xd8a1e681);	/* 22 */
			MD5_OP2(b, c, d, a, xp[4], 20, 0xe7d3fbc8);	/* 23 */
			MD5_OP2(a, b, c, d, xp[9], 5, 0x21e1cde6);	/* 24 */
			MD5_OP2(d, a, b, c, xp[14], 9, 0xc33707d6);	/* 25 */
			MD5_OP2(c, d, a, b, xp[3], 14, 0xf4d50d87);	/* 26 */
			MD5_OP2(b, c, d, a, xp[8], 20, 0x455a14ed);	/* 27 */
			MD5_OP2(a, b, c, d, xp[13], 5, 0xa9e3e905);	/* 28 */
			MD5_OP2(d, a, b, c, xp[2], 9, 0xfcefa3f8);	/* 29 */
			MD5_OP2(c, d, a, b, xp[7], 14, 0x676f02d9);	/* 30 */
			MD5_OP2(b, c, d, a, xp[12], 20, 0x8d2a4c8a);	/* 31 */

			/* round 3 */
			MD5_OP3(a, b, c, d, xp[5], 4, 0xfffa3942);	/* 32 */
			MD5_OP3(d, a, b, c, xp[8], 11, 0x8771f681);	/* 33 */
			MD5_OP3(c, d, a, b, xp[11], 16, 0x6d9d6122);	/* 34 */
			MD5_OP3(b, c, d, a, xp[14], 23, 0xfde5380c);	/* 35 */
			MD5_OP3(a, b, c, d, xp[1], 4, 0xa4beea44);	/* 36 */
			MD5_OP3(d, a, b, c, xp[4], 11, 0x4bdecfa9);	/* 37 */
			MD5_OP3(c, d, a, b, xp[7], 16, 0xf6bb4b60);	/* 38 */
			MD5_OP3(b, c, d, a, xp[10], 23, 0xbebfbc70);	/* 39 */
			MD5_OP3(a, b, c, d, xp[13], 4, 0x289b7ec6);	/* 40 */
			MD5_OP3(d, a, b, c, xp[0], 11, 0xeaa127fa);	/* 41 */
			MD5_OP3(c, d, a, b, xp[3], 16, 0xd4ef3085);	/* 42 */
			MD5_OP3(b, c, d, a, xp[6], 23, 0x04881d05);	/* 43 */
			MD5_OP3(a, b, c, d, xp[9], 4, 0xd9d4d039);	/* 44 */
			MD5_OP3(d, a, b, c, xp[12], 11, 0xe6db99e5);	/* 45 */
			MD5_OP3(c, d, a, b, xp[15], 16, 0x1fa27cf8);	/* 46 */
			MD5_OP3(b, c, d, a, xp[2], 23, 0xc4ac5665);	/* 47 */

			/* round 4 */
			MD5_OP4(a, b, c, d, xp[0], 6, 0xf4292244);	/* 48 */
			MD5_OP4(d, a, b, c, xp[7], 10, 0x432aff97);	/* 49 */
			MD5_OP4(c, d, a, b, xp[14], 15, 0xab9423a7);	/* 50 */
			MD5_OP4(b, c, d, a, xp[5], 21, 0xfc93a039);	/* 51 */
			MD5_OP4(a, b, c, d, xp[12], 6, 0x655b59c3);	/* 52 */
			MD5_OP4(d, a, b, c, xp[3], 10, 0x8f0ccc92);	/* 53 */
			MD5_OP4(c, d, a, b, xp[10], 15, 0xffeff47d);	/* 54 */
			MD5_OP4(b, c, d, a, xp[1], 21, 0x85845dd1);	/* 55 */
			MD5_OP4(a, b, c, d, xp[8], 6, 0x6fa87e4f);	/* 56 */
			MD5_OP4(d, a, b, c, xp[15], 10, 0xfe2ce6e0);	/* 57 */
			MD5_OP4(c, d, a, b, xp[6], 15, 0xa3014314);	/* 58 */
			MD5_OP4(b, c, d, a, xp[13], 21, 0x4e0811a1);	/* 59 */
			MD5_OP4(a, b, c, d, xp[4], 6, 0xf7537e82);	/* 60 */
			MD5_OP4(d, a, b, c, xp[11], 10, 0xbd3af235);	/* 61 */
			MD5_OP4(c, d, a, b, xp[2], 15, 0x2ad7d2bb);	/* 62 */
			MD5_OP4(b, c, d, a, xp[9], 21, 0xeb86d391);	/* 63 */

			/*
			 * Update the results by adding the initial values of
			 * a, b, c and d to them, then write them back.
			 */
			a += results[0];
			results[0] = a;
			b += results[1];
			results[1] = b;
			c += results[2];
			results[2] = c;
			d += results[3];
			results[3] = d;
		}
	}

	/*
	 * Now add a length block if needed to complete this
	 */
	if(!incomplete && !alldone) {
		register uint32 x0, x14, x15;

		/*
		 * The last two words in the block contain the length in bits.
		 * Make it so.
		 */
		/* x0 = (uint32) 0; */
		x14 = (((uint32) (totallen)) << 3) & 0xffffffff;
		x15 = (uint32) ((totallen >> 29) & 0xffffffff);

		/*
		 * The first word will contain either a 0x80 or a 0, depending
		 * on whether the data run had a complete block or not.
		 */
		if(datalen & 0x3f) {  // 0011 1111
			x0 = 0;
		} else {
			x0 = 0x80;        // 
		}

		/* round 1 */
		MD5_OP1(a, b, c, d, x0, 7, 0xd76aa478);	/* 0 */
		MD5_OP1(d, a, b, c, 0, 12, 0xe8c7b756);	/* 1 */
		MD5_OP1(c, d, a, b, 0, 17, 0x242070db);	/* 2 */
		MD5_OP1(b, c, d, a, 0, 22, 0xc1bdceee);	/* 3 */
		MD5_OP1(a, b, c, d, 0, 7, 0xf57c0faf);	/* 4 */
		MD5_OP1(d, a, b, c, 0, 12, 0x4787c62a);	/* 5 */
		MD5_OP1(c, d, a, b, 0, 17, 0xa8304613);	/* 6 */
		MD5_OP1(b, c, d, a, 0, 22, 0xfd469501);	/* 7 */
		MD5_OP1(a, b, c, d, 0, 7, 0x698098d8);	/* 8 */
		MD5_OP1(d, a, b, c, 0, 12, 0x8b44f7af);	/* 9 */
		MD5_OP1(c, d, a, b, 0, 17, 0xffff5bb1);	/* 10 */
		MD5_OP1(b, c, d, a, 0, 22, 0x895cd7be);	/* 11 */
		MD5_OP1(a, b, c, d, 0, 7, 0x6b901122);	/* 12 */
		MD5_OP1(d, a, b, c, 0, 12, 0xfd987193);	/* 13 */
		MD5_OP1(c, d, a, b, x14, 17, 0xa679438e);	/* 14 */
		MD5_OP1(b, c, d, a, x15, 22, 0x49b40821);	/* 15 */

		/* round 2 */
		MD5_OP2(a, b, c, d, 0, 5, 0xf61e2562);	/* 16 */
		MD5_OP2(d, a, b, c, 0, 9, 0xc040b340);	/* 17 */
		MD5_OP2(c, d, a, b, 0, 14, 0x265e5a51);	/* 18 */
		MD5_OP2(b, c, d, a, x0, 20, 0xe9b6c7aa);	/* 19 */
		MD5_OP2(a, b, c, d, 0, 5, 0xd62f105d);	/* 20 */
		MD5_OP2(d, a, b, c, 0, 9, 0x02441453);	/* 21 */
		MD5_OP2(c, d, a, b, x15, 14, 0xd8a1e681);	/* 22 */
		MD5_OP2(b, c, d, a, 0, 20, 0xe7d3fbc8);	/* 23 */
		MD5_OP2(a, b, c, d, 0, 5, 0x21e1cde6);	/* 24 */
		MD5_OP2(d, a, b, c, x14, 9, 0xc33707d6);	/* 25 */
		MD5_OP2(c, d, a, b, 0, 14, 0xf4d50d87);	/* 26 */
		MD5_OP2(b, c, d, a, 0, 20, 0x455a14ed);	/* 27 */
		MD5_OP2(a, b, c, d, 0, 5, 0xa9e3e905);	/* 28 */
		MD5_OP2(d, a, b, c, 0, 9, 0xfcefa3f8);	/* 29 */
		MD5_OP2(c, d, a, b, 0, 14, 0x676f02d9);	/* 30 */
		MD5_OP2(b, c, d, a, 0, 20, 0x8d2a4c8a);	/* 31 */

		/* round 3 */
		MD5_OP3(a, b, c, d, 0, 4, 0xfffa3942);	/* 32 */
		MD5_OP3(d, a, b, c, 0, 11, 0x8771f681);	/* 33 */
		MD5_OP3(c, d, a, b, 0, 16, 0x6d9d6122);	/* 34 */
		MD5_OP3(b, c, d, a, x14, 23, 0xfde5380c);	/* 35 */
		MD5_OP3(a, b, c, d, 0, 4, 0xa4beea44);	/* 36 */
		MD5_OP3(d, a, b, c, 0, 11, 0x4bdecfa9);	/* 37 */
		MD5_OP3(c, d, a, b, 0, 16, 0xf6bb4b60);	/* 38 */
		MD5_OP3(b, c, d, a, 0, 23, 0xbebfbc70);	/* 39 */
		MD5_OP3(a, b, c, d, 0, 4, 0x289b7ec6);	/* 40 */
		MD5_OP3(d, a, b, c, x0, 11, 0xeaa127fa);	/* 41 */
		MD5_OP3(c, d, a, b, 0, 16, 0xd4ef3085);	/* 42 */
		MD5_OP3(b, c, d, a, 0, 23, 0x04881d05);	/* 43 */
		MD5_OP3(a, b, c, d, 0, 4, 0xd9d4d039);	/* 44 */
		MD5_OP3(d, a, b, c, 0, 11, 0xe6db99e5);	/* 45 */
		MD5_OP3(c, d, a, b, x15, 16, 0x1fa27cf8);	/* 46 */
		MD5_OP3(b, c, d, a, 0, 23, 0xc4ac5665);	/* 47 */

		/* round 4 */
		MD5_OP4(a, b, c, d, x0, 6, 0xf4292244);	/* 48 */
		MD5_OP4(d, a, b, c, 0, 10, 0x432aff97);	/* 49 */
		MD5_OP4(c, d, a, b, x14, 15, 0xab9423a7);	/* 50 */
		MD5_OP4(b, c, d, a, 0, 21, 0xfc93a039);	/* 51 */
		MD5_OP4(a, b, c, d, 0, 6, 0x655b59c3);	/* 52 */
		MD5_OP4(d, a, b, c, 0, 10, 0x8f0ccc92);	/* 53 */
		MD5_OP4(c, d, a, b, 0, 15, 0xffeff47d);	/* 54 */
		MD5_OP4(b, c, d, a, 0, 21, 0x85845dd1);	/* 55 */
		MD5_OP4(a, b, c, d, 0, 6, 0x6fa87e4f);	/* 56 */
		MD5_OP4(d, a, b, c, x15, 10, 0xfe2ce6e0);	/* 57 */
		MD5_OP4(c, d, a, b, 0, 15, 0xa3014314);	/* 58 */
		MD5_OP4(b, c, d, a, 0, 21, 0x4e0811a1);	/* 59 */
		MD5_OP4(a, b, c, d, 0, 6, 0xf7537e82);	/* 60 */
		MD5_OP4(d, a, b, c, 0, 10, 0xbd3af235);	/* 61 */
		MD5_OP4(c, d, a, b, 0, 15, 0x2ad7d2bb);	/* 62 */
		MD5_OP4(b, c, d, a, 0, 21, 0xeb86d391);	/* 63 */

		results[0] += a;
		results[1] += b;
		results[2] += c;
		results[3] += d;
	}
}
```







md5.h

```c
#ifndef MD5_H
#define MD5_H

/* MD5 context. */
typedef struct
{
    unsigned int state[4];    /* state (ABCD) */
    unsigned int count[2];    /* number of bits, modulo 2^64 (low-order word first) */
    unsigned char buffer[64]; /* input buffer */
} MD5_CTX;

#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

/* F, G, H and I are basic MD5 functions. */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

/* ROTATE_LEFT rotates x left n bits. */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32 - (n))))

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4. */
#define FF(a, b, c, d, x, s, ac)                            \
    {                                                       \
        (a) += F((b), (c), (d)) + (x) + (unsigned int)(ac); \
        (a) = ROTATE_LEFT((a), (s));                        \
        (a) += (b);                                         \
    }
#define GG(a, b, c, d, x, s, ac)                            \
    {                                                       \
        (a) += G((b), (c), (d)) + (x) + (unsigned int)(ac); \
        (a) = ROTATE_LEFT((a), (s));                        \
        (a) += (b);                                         \
    }
#define HH(a, b, c, d, x, s, ac)                            \
    {                                                       \
        (a) += H((b), (c), (d)) + (x) + (unsigned int)(ac); \
        (a) = ROTATE_LEFT((a), (s));                        \
        (a) += (b);                                         \
    }
#define II(a, b, c, d, x, s, ac)                            \
    {                                                       \
        (a) += I((b), (c), (d)) + (x) + (unsigned int)(ac); \
        (a) = ROTATE_LEFT((a), (s));                        \
        (a) += (b);                                         \
    }
#endif
```

- md5.c

```c
#include <stdio.h>
#include <string.h>
#include "md5.h"

void MD5Init(MD5_CTX *context);
void MD5Update(MD5_CTX *context, unsigned char *input, unsigned int inputLen);
void MD5Final(unsigned char digest[16], MD5_CTX *context);
static void MD5Transform(unsigned int state[4], unsigned char block[64]);
static void Encode(unsigned char *output, unsigned int *input, unsigned int len);
static void Decode(unsigned int *output, unsigned char *input, unsigned int len);
static void MD5_memcpy(unsigned char *output, unsigned char *input, unsigned int len);
static void MD5_memset(unsigned char *output, int value, unsigned int len);

static unsigned char PADDING[64] = {
    0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

/* MD5 initialization. Begins an MD5 operation, writing a new context.
 */
void MD5Init(MD5_CTX *context)
{
    // count[0]：存储长度的低32位
    // count[1]：高32位，合起来可以记录一个64位的长度。
    context->count[0] = context->count[1] = 0;
    /* Load magic initialization constants.
     */
    context->state[0] = 0x67452301;
    context->state[1] = 0xefcdab89;
    context->state[2] = 0x98badcfe;
    context->state[3] = 0x10325476;
}

/*
 * MD5 block update operation. Continues an MD5 message-digest
 * operation, processing another message block, and updating the
 * context.
 * MD5数据填充与处理逻辑:
 *    逐步处理输入数据块，并将其分块为64字节（512位）大小进行哈希计算。
 *    负责将任意长度的输入数据分块为64字节块，并在缓冲区中逐步累积和处理数据，最终生成MD5哈希值
 */

/**
 * 假设input长度为100字节
 *    input_len << 3：转为800bit
 */
void MD5Update(MD5_CTX *context, unsigned char *input, unsigned int inputLen)
{
    unsigned int i, index, partLen;

    /* Compute number of bytes mod 64 */
    // context->count[0]：低32位的计数器 记录了当前处理的总位数
    // context->count[1]：是高32位计数器
    // 1.当前数据已经填充了index字节，新的数据需要从这个位置开始填入缓冲区:
    //   >> 3 将位数转化为字节数（每8位为1字节）
    //   & 0x3F(0011 1111)：只取后6位，表示取模64，确定缓冲区中已有数据的偏移位置（缓冲区为64字节块）
    index = (unsigned int)((context->count[0] >> 3) & 0x3F);

    /* Update number of bits */
    // 2.更新已处理的位数，确保支持超过 2³² 位（即 512MB）的输入数据
    //   将输入数据的长度（字节数）转换为位数，并累加到 count[0] 中；如果累加后溢出（即加法结果小于之前的值），则高位计数器 count[1] 自增 1。
    // 处理溢出后，剩余的高位位数加到 count[1]。
    if ((context->count[0] += ((unsigned int)inputLen << 3)) < ((unsigned int)inputLen << 3))
    {
        context->count[1]++;
    }
    context->count[1] += ((unsigned int)inputLen >> 29);

    // 表示当前缓冲区还剩余的可用字节数。
    partLen = 64 - index;

    /* Transform as many times as possible. */
    // 如果输入数据的长度 inputLen 大于等于缓冲区剩余空间 partLen
    if (inputLen >= partLen)
    {
        // 如果能凑齐一个 64 字节块，立即处理它，确保数据不会堆积。
        // 先将缓冲区填满（从 index 开始填充 partLen 字节）。
        MD5_memcpy((unsigned char *)&context->buffer[index], (unsigned char *)input, partLen);
        // 调用 MD5Transform 对已满的缓冲区进行一次 MD5 块变换处理
        MD5Transform(context->state, context->buffer);

        // 对输入数据中剩余的完整 64 字节块进行逐块变换处理。
        // 从 i = partLen 开始（跳过刚才填满缓冲区的部分），每次处理 64 字节块。
        for (i = partLen; i + 63 < inputLen; i += 64)
        {
            MD5Transform(context->state, &input[i]);
        }

        // 将当前无法组成完整块的输入数据暂存到缓冲区中，等待后续处理
        // 剩余数据不足 64 字节时，将这些数据保存到缓冲区中。
        // 从缓冲区的起始位置 index = 0 开始填充，填充字节数为 inputLen - i。
        index = 0;
    }
    else
    {
        i = 0;
    }

    /* Buffer remaining input */
    MD5_memcpy((unsigned char *)&context->buffer[index], (unsigned char *)&input[i], inputLen - i);
}

/* MD5 finalization. Ends an MD5 message-digest operation, writing the
 the message digest and zeroizing the context.
 */
void MD5Final(unsigned char digest[16], MD5_CTX *context)
{
    unsigned char bits[8];
    unsigned int index, padLen;

    /* Save number of bits */
    Encode(bits, context->count, 8);

    /* Pad out to 56 mod 64. */
    index = (unsigned int)((context->count[0] >> 3) & 0x3f);
    padLen = (index < 56) ? (56 - index) : (120 - index);
    MD5Update(context, PADDING, padLen);

    /* Append length (before padding) */
    MD5Update(context, bits, 8);

    /* Store state in digest */
    Encode(digest, context->state, 16);

    /* Zeroize sensitive information. */
    MD5_memset((unsigned char *)context, 0, sizeof(*context));
}

/* MD5 basic transformation. Transforms state based on block.
 */
static void MD5Transform(unsigned int state[4], unsigned char block[64])
{
    unsigned int a = state[0], b = state[1], c = state[2], d = state[3], x[16];
    // 将64字节转为 unsigned int x[16];de
    Decode(x, block, 64);
    /* Round 1 */
    FF(a, b, c, d, x[0], S11, 0xd76aa478);  /* 1 */
    FF(d, a, b, c, x[1], S12, 0xe8c7b756);  /* 2 */
    FF(c, d, a, b, x[2], S13, 0x242070db);  /* 3 */
    FF(b, c, d, a, x[3], S14, 0xc1bdceee);  /* 4 */
    FF(a, b, c, d, x[4], S11, 0xf57c0faf);  /* 5 */
    FF(d, a, b, c, x[5], S12, 0x4787c62a);  /* 6 */
    FF(c, d, a, b, x[6], S13, 0xa8304613);  /* 7 */
    FF(b, c, d, a, x[7], S14, 0xfd469501);  /* 8 */
    FF(a, b, c, d, x[8], S11, 0x698098d8);  /* 9 */
    FF(d, a, b, c, x[9], S12, 0x8b44f7af);  /* 10 */
    FF(c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
    FF(b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
    FF(a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
    FF(d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
    FF(c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
    FF(b, c, d, a, x[15], S14, 0x49b40821); /* 16 */
    /* Round 2 */
    GG(a, b, c, d, x[1], S21, 0xf61e2562);  /* 17 */
    GG(d, a, b, c, x[6], S22, 0xc040b340);  /* 18 */
    GG(c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
    GG(b, c, d, a, x[0], S24, 0xe9b6c7aa);  /* 20 */
    GG(a, b, c, d, x[5], S21, 0xd62f105d);  /* 21 */
    GG(d, a, b, c, x[10], S22, 0x2441453);  /* 22 */
    GG(c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
    GG(b, c, d, a, x[4], S24, 0xe7d3fbc8);  /* 24 */
    GG(a, b, c, d, x[9], S21, 0x21e1cde6);  /* 25 */
    GG(d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
    GG(c, d, a, b, x[3], S23, 0xf4d50d87);  /* 27 */
    GG(b, c, d, a, x[8], S24, 0x455a14ed);  /* 28 */
    GG(a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
    GG(d, a, b, c, x[2], S22, 0xfcefa3f8);  /* 30 */
    GG(c, d, a, b, x[7], S23, 0x676f02d9);  /* 31 */
    GG(b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
    /* Round 3 */
    HH(a, b, c, d, x[5], S31, 0xfffa3942);  /* 33 */
    HH(d, a, b, c, x[8], S32, 0x8771f681);  /* 34 */
    HH(c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
    HH(b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
    HH(a, b, c, d, x[1], S31, 0xa4beea44);  /* 37 */
    HH(d, a, b, c, x[4], S32, 0x4bdecfa9);  /* 38 */
    HH(c, d, a, b, x[7], S33, 0xf6bb4b60);  /* 39 */
    HH(b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
    HH(a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
    HH(d, a, b, c, x[0], S32, 0xeaa127fa);  /* 42 */
    HH(c, d, a, b, x[3], S33, 0xd4ef3085);  /* 43 */
    HH(b, c, d, a, x[6], S34, 0x4881d05);   /* 44 */
    HH(a, b, c, d, x[9], S31, 0xd9d4d039);  /* 45 */
    HH(d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
    HH(c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
    HH(b, c, d, a, x[2], S34, 0xc4ac5665);  /* 48 */
    /* Round 4 */
    II(a, b, c, d, x[0], S41, 0xf4292244);  /* 49 */
    II(d, a, b, c, x[7], S42, 0x432aff97);  /* 50 */
    II(c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
    II(b, c, d, a, x[5], S44, 0xfc93a039);  /* 52 */
    II(a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
    II(d, a, b, c, x[3], S42, 0x8f0ccc92);  /* 54 */
    II(c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
    II(b, c, d, a, x[1], S44, 0x85845dd1);  /* 56 */
    II(a, b, c, d, x[8], S41, 0x6fa87e4f);  /* 57 */
    II(d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
    II(c, d, a, b, x[6], S43, 0xa3014314);  /* 59 */
    II(b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
    II(a, b, c, d, x[4], S41, 0xf7537e82);  /* 61 */
    II(d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
    II(c, d, a, b, x[2], S43, 0x2ad7d2bb);  /* 63 */
    II(b, c, d, a, x[9], S44, 0xeb86d391);  /* 64 */
    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;
    /* Zeroize sensitive information. */
    MD5_memset((unsigned char *)x, 0, sizeof(x));
}

/* Encodes input (UINT4) into output (unsigned char). Assumes len is
 a multiple of 4.
 */
static void Encode(unsigned char *output, unsigned int *input, unsigned int len)
{
    unsigned int i, j;

    for (i = 0, j = 0; j < len; i++, j += 4)
    {
        output[j] = (unsigned char)(input[i] & 0xff);
        output[j + 1] = (unsigned char)((input[i] >> 8) & 0xff);
        output[j + 2] = (unsigned char)((input[i] >> 16) & 0xff);
        output[j + 3] = (unsigned char)((input[i] >> 24) & 0xff);
    }
}
/* Decodes input (unsigned char) into output (UINT4). Assumes len is
 a multiple of 4.
 */
// 将输入的字节数组 input 中的字节转换为无符号整数，并将转换后的结果存储到 output 数组中。
static void Decode(unsigned int *output, unsigned char *input, unsigned int len)
{
    unsigned int i, j;

    // 每次循环处理 4 个字节（每个无符号整数有 4 个字节）
    for (i = 0, j = 0; j < len; i++, j += 4)
    {
        // 对于每 4 个字节，构造一个 32 位的无符号整数。这个整数的每个字节都通过按位操作（位移和或运算）合成一个完整的 32 位值。
        output[i] = ((unsigned int)input[j]) | (((unsigned int)input[j + 1]) << 8) | (((unsigned int)input[j + 2]) << 16) | (((unsigned int)input[j + 3]) << 24);
    }
}
/* Note: Replace "for loop" with standard memcpy if possible.
 */
static void MD5_memcpy(unsigned char *output, unsigned char *input, unsigned int len)
{
    unsigned int i;
    for (i = 0; i < len; i++)
        output[i] = input[i];
}

/* Note: Replace "for loop" with standard memset if possible.
 */
static void MD5_memset(unsigned char *output, int value, unsigned int len)
{
    unsigned int i;
    for (i = 0; i < len; i++)
        ((char *)output)[i] = (char)value;
}

#ifndef MD
#define MD 5
#define MD_CTX MD5_CTX
#define MDInit MD5Init
#define MDUpdate MD5Update
#define MDFinal MD5Final
#endif

/* Prints a message digest in hexadecimal.
 */
static void MDPrint(digest) unsigned char digest[16];
{
    unsigned int i;
    for (i = 0; i < 16; i++)
        printf("%02x", digest[i]);
}

/* Digests a string and prints the result.
 */
static void MDString(char *string)
{
    MD_CTX context;
    unsigned char digest[16];
    unsigned int len = strlen(string);

    MDInit(&context);
    MDUpdate(&context, string, len);
    MDFinal(digest, &context);
    printf("MD%d (\"%s\") = ", MD, string);
    MDPrint(digest);
    printf("\n");
}

/* Digests a reference suite of strings and prints the results.
 */
static void MDTestSuite()
{
    printf("MD%d test suite:\n", MD);
    MDString("");
    MDString("a");
    MDString("abc");
    MDString("message digest");
    MDString("abcdefghijklmnopqrstuvwxyz");
    MDString("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
    MDString("1234567890123456789012345678901234567890\
1234567890123456789012345678901234567890");
}

int main()
{
    MDTestSuite();
}
```



## include

### rip_main.h

```c
#define RIP_AUTH_PWD_MD5		2
/* ip rip dynamic-key 1 md5 xxxx-xx-xx-xx:xx  xx:xx { um-mode pwd | pwd } */
#define RIP_AUTH_PWD_DYNC_MD5	3
/* sha1 */  /* ip rip dynamic-key 1  sha1 xxxx-xx-xx-xx:xx  xx:xx { um-mode pwd | pwd } */
#define RIP_AUTH_PWD_DYNC_SHA1	4

/* hmac-md5、hmac-sha1、hmac-sha256 */
#define RIP_AUTH_PWD_DYNC_HMAC_MD5     5
#define RIP_AUTH_PWD_DYNC_HMAC_SHA1    6
#define RIP_AUTH_PWD_DYNC_HMAC_SHA256  7
```



#### dynamic_key_list_

```c
/*邻居的动态key链表*/
typedef struct dynamic_key_list_
{
	struct dynamic_key_list_ *forw, *back;/*key链表*/
	uint32 key_state;/*key的状态[超时|激活|为使用|延期]*/
	uint8 key_id;/*key id*/
	uint8 algorithms;/*算法(RIP_NEIGHB_MD5/RIP_NEIGHB_SHA1)*/
	uint8 um_mode;/* UM加密类型: 0, 2, 5, 7 等， 存储时，按照需求，采用0，2， 5类型存储，show run时，采用对应加密显示*/
	char key[20+1];/*存的是MD5或者SHA1的明文，填充报文是，调用rt_md5_cksum、 rip_sha1_cksum来填充报文*/
	struct key_start_time_ start_time;/*开始生效时间*/
	struct key_lift_time_ lift_time;/*有效时间长度*/

    char hmac_key[32+1]; /* 存放HMAC-MD5、HMAC-SHA1、HMAC-SHA256 */
    
	/*Fengsb add 2022-07-09 韩国安规，saltid和aes_key都供UM读写
	#if defined(KOREA_8595) || defined(INCLUDE_HANTECH)	*/
	uint32	saltid;
	char aes_key[AES_ARRY_SZ];
	/* #endif */
}key_list_t;
```

#### rip_authen_tail_

```c
/*rip动态认证的尾部*/
typedef struct rip_authen_tail_
{
	uint16 afi;
	uint16 route_tag;
	union 
	{
		char md5[16];
		char sha1[20];
        char sha256[32];
	}key;
}rip_authen_tail_t;
```





## src

```c
Switch_config_v8#ip rip dynamic-key 3 ?    
RIP: rip_neigh_cmd_do_keyid: argc=2 *argv=3 
  md5   -- Md5
  sha1  -- Sha1
  
Switch_config_v8#ip rip dynamic-key 3 sha1 ?
RIP: rip_neigh_cmd_do_keyid: argc=3 *argv=3 
RIP: rip_neigh_cmd_do_sha1: argc=2 *argv=sha1
  xxxx-xx-xx-xx:xx  -- Year-month-day-hour:minute  (24h)
  
Switch_config_v8#ip rip dynamic-key 3 sha1 2024-12-10-08:00 ?
RIP: rip_neigh_cmd_do_keyid: argc=4 *argv=3 
RIP: rip_neigh_cmd_do_sha1: argc=3 *argv=sha1 
  xx:xx  -- Hour:minute  (key's effective time length )
                          
Switch_config_v8#ip rip dynamic-key 3 sha1 2024-12-10-08:00 10:00 ?
RIP: rip_neigh_cmd_do_keyid: argc=5 *argv=3 
RIP: rip_neigh_cmd_do_sha1: argc=4 *argv=sha1 
RIP: rip_intf_cmd_do_key_lift_time: argc=2 *argv=10:00 
  2  -- User plain password used for the SHA256 encrypt
```

```c
Switch_config_v8#ip rip dynamic-key 3 md5 2024-12-10-10:30 24:00 abc123
RIP: rip_neigh_cmd_do_keyid: argc=5 *argv=3 
RIP:rip_auth_um_mode: u->struct_p[3]:0x2f, cmd_mskbits:0x2e, line:2423, argc=1, argv:abc123
```



### rip_packet.c

#### rip_auth_check

```c
if (key->algorithms == RIP_NEIGHB_MD5)
{
	memcpy(password_md5, authen_tail->key.md5, 16);
	memcpy(authen_tail->key.md5, key->key, 16);
	rt_md5_cksum((byte *)rip_recv_buffer, packet_len, packet_len, authen_tail->key.md5, (uint32*)0);
	if (memcmp(authen_tail->key.md5, password_md5, 16) != 0)
	{
		/*debug ip rip protocol*/
		rip_debug(RIP_DEBUG_IP_RIP_PROTO_RECV, "RIP: ignored V%d packet from %s (dynamic authentication failed(%d))\n",
		rip_pkt_head->version, ip_ntoa(src_addr), __LINE__);
		return RIP_FAIL;
	}
}
else if (key->algorithms == RIP_NEIGHB_SHA1)
{
	memcpy(password_sha1, authen_tail->key.sha1, 20);
	memcpy(authen_tail->key.sha1, key->key, 20);
	rip_sha1_cksum((byte *)rip_recv_buffer, packet_len, packet_len, authen_tail->key.sha1, (uint32*)0);
	if (memcmp(authen_tail->key.sha1, password_sha1, 20) != 0)
	{
		/*debug ip rip protocol*/
		rip_debug( RIP_DEBUG_IP_RIP_PROTO_RECV, "RIP: ignored V%d packet from %s (dynamic authentication failed(%d))\n",
		rip_pkt_head->version, ip_ntoa(src_addr), __LINE__);
		return RIP_FAIL;
	}
}
/* add */
else if (key->algorithms == RIP_AUTH_PWD_DYNC_HMAC_MD5)
{
    memcpy(password_md5, authen_tail->key.md5, 16);
	memcpy(authen_tail->key.md5, key->key, 16);

	rt_md5_cksum((byte *)rip_recv_buffer, packet_len, packet_len, authen_tail->key.md5, (uint32*)0);
	if (memcmp(authen_tail->key.md5, password_md5, 16) != 0)
	{
		/*debug ip rip protocol*/
		rip_debug(RIP_DEBUG_IP_RIP_PROTO_RECV, "RIP: ignored V%d packet from %s (dynamic authentication failed(%d))\n",
		rip_pkt_head->version, ip_ntoa(src_addr), __LINE__);
		return RIP_FAIL;
	}
}
else if (key->algorithms == RIP_AUTH_PWD_DYNC_HMAC_SHA1)
{
	memcpy(password_sha1, authen_tail->key.sha1, 20);
	memcpy(authen_tail->key.sha1, key->key, 20);
	rip_sha1_cksum((byte *)rip_recv_buffer, packet_len, packet_len, authen_tail->key.sha1, (uint32*)0);
	if (memcmp(authen_tail->key.sha1, password_sha1, 20) != 0)
	{
		/*debug ip rip protocol*/
		rip_debug( RIP_DEBUG_IP_RIP_PROTO_RECV, "RIP: ignored V%d packet from %s (dynamic authentication failed(%d))\n",
		rip_pkt_head->version, ip_ntoa(src_addr), __LINE__);
		return RIP_FAIL;
	}
}
else if (key->algorithms == RIP_AUTH_PWD_DYNC_HMAC_SHA256)
{
	memcpy(password_sha1, authen_tail->key.sha1, 20);
	memcpy(authen_tail->key.sha1, key->key, 20);
	rip_sha1_cksum((byte *)rip_recv_buffer, packet_len, packet_len, authen_tail->key.sha1, (uint32*)0);
	if (memcmp(authen_tail->key.sha1, password_sha1, 20) != 0)
	{
		/*debug ip rip protocol*/
		rip_debug( RIP_DEBUG_IP_RIP_PROTO_RECV, "RIP: ignored V%d packet from %s (dynamic authentication failed(%d))\n",
		rip_pkt_head->version, ip_ntoa(src_addr), __LINE__);
		return RIP_FAIL;
	}
}
else
{
	return RIP_FAIL;
}
```



### rip_cmd.c

#### 1.rip_neighbor_cmds_key_algorithems_tab

```c
 /*设置dynamic_key下的key算法的子命令*/
struct cmds rip_neighbor_cmds_key_algorithems_tab[]  = 
{
	{ 
		"md5",
		MATCH_AMB, 
		cmdPref(PF_CMDNO, 0, 0), 
		0,
		rip_neigh_cmd_do_md5,
		NULL,
		NULL,
		0,
		0,
		"md5			-- md5",
		"md5			-- md5算法",
		NULLCHAR,
		NULLCHAR
	},
	{ 
		"sha1",
		MATCH_AMB, 
		cmdPref(PF_CMDNO, 0, 0), 
		0,
		rip_neigh_cmd_do_sha1,
		NULL,
		NULL,
		0,
		0,
		"sha1			-- sha1",
		"sha1			-- sha1算法",
		NULLCHAR,
		NULLCHAR
	},
	{ 
		"hmac-md5",
		MATCH_AMB, 
		cmdPref(PF_CMDNO, 0, 0), 
		0,
		rip_neigh_cmd_do_hmac_md5,
		NULL,
		NULL,
		0,
		0,
		"hmac-md5		-- hmac-md5",
		"hmac-md5		-- hmac-md5算法",
		NULLCHAR,
		NULLCHAR
	},
    { 
		"hmac-sha1",
		MATCH_AMB, 
		cmdPref(PF_CMDNO, 0, 0), 
		0,
		rip_neigh_cmd_do_hmac_sha1,
		NULL,
		NULL,
		0,
		0,
        "hmac-sha1		-- hmac-sha1",
		"hmac-sha1		-- hmac-sha1算法",
		NULLCHAR,
		NULLCHAR
	},
    { 
		"hmac-sha256",
		MATCH_AMB, 
		cmdPref(PF_CMDNO, 0, 0), 
		0,
		rip_neigh_cmd_do_hmac_sha256,
		NULL,
		NULL,
		0,
		0,
		"hmac-sha256    -- hmac-sha256",
		"hmac-sha256	-- hmac-sha256算法",
		NULLCHAR,
		NULLCHAR
	},
	{
		"<cr>", 
	  	MATCH_END, 
	  	cmdPref(0, 0, PF_NOCMDNOR), 
	  	0,NULL,NULL,NULL,0,0,
	  	"<cr>", 
	  	"<cr>", 
	  	NULLCHAR, 
	 	 NULLCHAR
	},
	
	{ NULLCHAR }
};
```



##### rip_neigh_cmd_do_hmac_md5

```c
/* ip rip dynamic-key 1 hmac-md5 xxxx-xx-xx-xx:xx xx:xx { um-mode } pwd key  */
int  rip_neigh_cmd_do_hmac_md5(int argc, char **argv, struct user *u)
{
	int ret;
	switch(TypeOfFunc(u)) 
	{
		case NORMAL_FUNC:
			u->struct_p[4] = RIP_AUTH_PWD_DYNC_HMAC_MD5;
			return subcmd( rip_neighbor_cmds_key_start_time_tab , NULL, argc, argv, u );
			break;
		case NOPREF_FUNC:
			ret = cmdend(argc - 1, argv + 1, u);
			if(ret != 0)
			{
				return ret;
		    }
			ret = rip_neighb_delte_key(argc,argv,u);
			if(ret != RIP_SUCCESS)
				return RIP_FAIL;
			break;
		default:
			break;
	}

	return RIP_SUCCESS;	
}
/* ip rip dynamic-key 1 hmac-sha1 xxxx-xx-xx-xx:xx xx:xx { um-mode pwd | pwd } { um-mode key | key } */
/* ip rip dynamic-key 1 hmac-sha256 xxxx-xx-xx-xx:xx xx:xx { um-mode pwd | pwd } { um-mode key | key }*/
int  rip_neigh_cmd_do_hmac_sha1(int argc, char **argv, struct user *u)
{
	int ret;
	switch(TypeOfFunc(u)) 
	{
		case NORMAL_FUNC:
			/*Fengsb 2022-08-01*/
			u->struct_p[4] = RIP_AUTH_PWD_DYNC_HMAC_SHA1;
			/*Fengsb 2022-08-01*/
			return subcmd( rip_neighbor_cmds_key_start_time_tab , NULL, argc, argv, u );
			break;
		case NOPREF_FUNC:
			ret = cmdend(argc - 1, argv + 1, u);
			if(ret != 0)
			{
				return ret;
		    	}
			ret = rip_neighb_delte_key(argc,argv,u);
			if(ret != RIP_SUCCESS)
				return RIP_FAIL;
			break;
		default:
			break;
	}

	return RIP_SUCCESS;
}

int  rip_neigh_cmd_do_hmac_sha256(int argc, char **argv, struct user *u)
{
	int ret;
	switch(TypeOfFunc(u)) 
	{
		case NORMAL_FUNC:
			/*Fengsb 2022-08-01*/
			u->struct_p[4] = RIP_AUTH_PWD_DYNC_HMAC_SHA256;
			/*Fengsb 2022-08-01*/
			return subcmd( rip_neighbor_cmds_key_start_time_tab , NULL, argc, argv, u );
			break;
		case NOPREF_FUNC:
			ret = cmdend(argc - 1, argv + 1, u);
			if(ret != 0)
			{
				return ret;
		    	}
			ret = rip_neighb_delte_key(argc,argv,u);
			if(ret != RIP_SUCCESS)
				return RIP_FAIL;
			break;
		default:
			break;
	}

	return RIP_SUCCESS;
}
```

#### rip_neighbor_cmds_key_start_time_tab

```c
/*设置dynamic_key下的key生效时间子命令*/
struct cmds rip_neighbor_cmds_key_start_time_tab[]  = 
{
	{ 
		"1234567890",
		MATCH_STR, 
		0, 
		0,
		rip_neigh_cmd_do_key_start_time,
		NULL,
		NULL,
		0,
		0,
		"xxxx-xx-xx-xx:xx              -- year-month-day-hour:minute  (24h)", 
		"xxxx-xx-xx-xx:xx              -- 年-月-日-时:分 （24小时制）",
		NULLCHAR,
		NULLCHAR
	},	
	{ NULLCHAR }
};

int  rip_neigh_cmd_do_key_start_time(int argc, char **argv, struct user *u)
{
	return subcmd( rip_neighbor_cmds_key_lift_time_tab , NULL, argc, argv, u );
}

/*设置dynamic_key下的key有效时间长度子命令*/
struct cmds rip_neighbor_cmds_key_lift_time_tab[]  = 
{
	{ 
		"1234567890",
		MATCH_STR, 
		0, 
		0,
		rip_intf_cmd_do_key_lift_time,
		NULL,
		NULL,
		0,
		0,
		"xx:xx            -- hour:minute  (key's effective time length )", 
		"xx:xx            -- 小时:分钟 （key的有效时间长度）",
		NULLCHAR,
		NULLCHAR
	},
	{ NULLCHAR }
};
```

#### rip_intf_cmd_do_key_lift_time

```c
int  rip_intf_cmd_do_key_lift_time(int argc, char **argv, struct user *u)
{
	char time_str[20] = {'\0'};
	struct rip_intf_ *rif = NULL;
	struct dynamic_key_list_ *key = NULL;
	struct parameter param;
	int32 device_index;
	int ret;
/*
	ret = cmdend(argc - 2, argv + 2, u);
    if (ret != 0)
    {
        return ret;
    }
*/	
	device_index = u->struct_p[1];
	rif = rip_intf_array[device_index];
	if(rif == NULL)
	{
       	return RIP_FAIL;
	}

	/* argc 和 argv是从命令行倒着往前计数, 下面是调试打印信息
	Switch_config_v1#ip rip dy 1 md5 ?
  	xxxx-xx-xx-xx:xx  -- Year-month-day-hour:minute  (24h)
	Switch_config_v1#Jan  1 00:02:56 RIP: key_lift_time: argc = 2, *argv=md5

	Switch_config_v1#ip rip dy 1 md5 2022-08-05-10:55  ?
  	xx:xx  -- Hour:minute  (key's effective time length )
	Switch_config_v1#Jan  1 00:05:32 RIP: key_lift_time: argc = 3, *argv=md5

	Switch_config_v1#ip rip dy 1 md5 2022-08-05-10:55 20:11 ?
	Switch_config_v1#Jan  1 00:07:26 RIP: key_lift_time: argc = 4, *argv=md5
	
	Jan  1 00:07:26 RIP: key_lift_time: argc = 2, *argv=20:11
	ip rip dy 1 md5 2022-08-05-10:55  20:11 
	 */	 

	/*配置新的 key*/
	key = (struct dynamic_key_list_ *)rip_mem_malloc( sizeof(struct dynamic_key_list_), RIP_NEIGHB_KEY_TYPE );
	if( key == NULL )
	{
		/*内存分配失败*/
		fprintf(stderr, "RIP: Malloc memory failed.(%s, %d)\n", __FILE__, __LINE__ );
		return RIP_MEM_FAIL;
	}
	memset( key, 0, sizeof(struct dynamic_key_list_) );
	QUE_INIT(key);

	key->key_id = u->struct_p[2];
	ret = rip_intf_add_keyid_check(key, device_index);
	if(ret != RIP_SUCCESS)
	{
		printf("warning: there has been a key with this keyid,adding fail!\n");
		rip_mem_free( key, RIP_NEIGHB_KEY_TYPE );
		return RIP_FAIL;
	}

	if( u->struct_p[4] == RIP_AUTH_PWD_DYNC_MD5)
		key->algorithms = RIP_NEIGHB_MD5;
	else if(u->struct_p[4] == RIP_AUTH_PWD_DYNC_SHA1)
		key->algorithms = RIP_NEIGHB_SHA1;
    /* add */
    else if(u->struct_p[4] == RIP_AUTH_PWD_DYNC_HMAC_MD5)
        key->algorithms = RIP_NEIGHB_HMAC_MD5;
    else if(u->struct_p[4] == RIP_AUTH_PWD_DYNC_HMAC_SHA1)
        key->algorithms = RIP_NEIGHB_HMAC_SHA1;
    else if(u->struct_p[4] == RIP_AUTH_PWD_DYNC_HMAC_SHA256)
		key->algorithms = RIP_NEIGHB_HMAC_SHA256;
    
	/*get key start time */
	param.type = ARG_STR;
    param.min = 16;
	param.max = 16;

	param.flag = ARG_MIN | ARG_MAX;
	ret = getparameter(argc + 2, argv - 2, u, &param);
	if(ret != 0)
	{
		rip_mem_free( key, RIP_NEIGHB_KEY_TYPE );
		return ret;
	}	
	strcpy(time_str , param.value.v_string);

	ret = rip_intf_cmd_start_time_save(time_str , key);
	if(ret != RIP_SUCCESS)
	{
		printf("error: fault key start_time format!adding fail!\n");
		rip_mem_free( key, RIP_NEIGHB_KEY_TYPE );
		return RIP_FAIL;
	}

	/*get key's lift time*/
	param.type = ARG_STR;
    param.min = 5;
	param.max = 5;
	param.flag = ARG_MIN | ARG_MAX;
	ret = getparameter(argc + 1, argv - 1, u, &param);
	if(ret != 0)
	{
		rip_mem_free( key, RIP_NEIGHB_KEY_TYPE );
		return ret;
	}
	memset(time_str, 0, 20);
	strcpy(time_str, param.value.v_string);

	ret = rip_intf_cmd_lift_time_save(time_str , key);
	if(ret != RIP_SUCCESS)
	{
		rip_mem_free( key, RIP_NEIGHB_KEY_TYPE );
		return RIP_FAIL;
	}

	/*将key添加到neighbor 的key链表下*/
	ret = rip_neighb_add_key(key,device_index);
	if(ret != RIP_SUCCESS)
	{
		rip_mem_free( key, RIP_NEIGHB_KEY_TYPE );
		return RIP_FAIL;
	}

	/* UM类型配置，以及交互式 password配置  以及对应处理 */
	ret = rip_auth_pwd_config(argc, argv, u);

	if(ret != RIP_SUCCESS)
	{
		rip_neighb_key_del(device_index,key->key_id,key->algorithms);
	}
	else
	{
		sys_start_timer( rif->key_start_timer_id, 60);
		sys_start_timer( rif->key_lift_timer_id, 60);
	}

	return RIP_SUCCESS;
}
```



#### rip_auth_pwd_config

```c
typedef struct RT_um_auth_info
{
	UINT32 flag;			/*当前状态，已经存在PWD_EXIST,  新传入的PWD_NEW， 做为返回值使用*/
	char passw[MaxLenPwd+1];/*保存加密时的明文密码*/	
	UINT32 salt;			/*盐值，mode 6时需要这个值; 值为0时，UM会为其分配一个值；
							  非零时，UM以这个值做为密文反算明文的依据以挤保相同盐值，相同明文，算出的密文是一致的*/
	UINT8 mode;				/* um当前使用的加密模式, 0,7; 2,6; 5,9*/
   	char master_key[AES_ARRY_SZ];	/* mode 9时需要这个值*/
}RT_UM_AUTH_INFO;
```



```c
static int rip_auth_pwd_config(int argc, char *argv[], struct user *u)
{
#if defined(KOREA_8595) || defined(INCLUDE_HANTECH)
	char hantech[30] = {0};
#endif

	/* 因为 MESSAGE_PARAM 字节在后续传递消息内容时，当前应用已经把内部字段全部用完了
	所以这里需要传递RT_UM_AUTH_INFO里面的内容，要么动态申请一块内存，要么通过限定变量
	的作用域，带入enpassw的地址来传递内容。
	如果担心函数栈空间不够的话，关键是考虑到GR操作，所以这里申请一块堆空间来处理RT_UM_AUTH_INFO结构*/
	RT_UM_AUTH_INFO *enpassw = NULL;
	struct rip_intf_ *rif = NULL;
	uint32 device_index;
	int rc = 0;

	/*check the device index add by fangqi  2006-10-11*/
	device_index = u->struct_p[1];
	rif = rip_intf_array[device_index];
	
	/*check the device index add by fangqi  2006-10-11*/
	if(rif == NULL)
	{
       	return RIP_FAIL;
	}

	enpassw = sys_mem_malloc(sizeof(RT_UM_AUTH_INFO));
	bzero((void *)enpassw, sizeof(RT_UM_AUTH_INFO));

	u->struct_p[6] = 0; /*用于后续保存um加密类型对应的标志位*/
	u->struct_p[5] = (unsigned long)enpassw;  /*用于保存被调函数获取的值*/
	u->struct_p[3] = UM_UNENCRY_0 | UM_ENCRY_SHA256_2 | UM_ENCRY_AES256_5 | UM_DECRY_7; 

	if(!passw_hidden_flag)
		u->struct_p[3] |= UM_UNHIDE_UNENCRY_PWD;

	if(!vty_startup_config_complete || !redn_msu_is_active())
		u->struct_p[3] |= UM_DECRY_7 | UM_DECRY_SHA256_6 | UM_DECRY_AES256_9;
	
#if defined(KOREA_8595) || defined(INCLUDE_HANTECH)
	if(!passw_hidden_flag)
		u->struct_p[3] |= UM_DECRY_SHA256_6 | UM_DECRY_AES256_9;

	u->struct_p[3] &= ~UM_UNENCRY_0;
	if(product_attribute_get_string("hantech", hantech, 30) == 0)
	{ 
		if(!strncmp(hantech,"yes",3))
			u->struct_p[3] &= ~UM_ENCRY_SHA256_2; 
		else
			u->struct_p[3] &= ~UM_ENCRY_AES256_5; 
	}
	else 
		u->struct_p[3] &= ~UM_ENCRY_AES256_5;

    u->struct_p[3] &= ~UM_UNENCRY_0;
	u->struct_p[3] &= ~UM_DECRY_7;
#endif
	u->cmd_mskbits = u->struct_p[3];

	/*
	Print("RIP:rip_auth_pwd_config: u->struct_p[3]:0x%x, cmd_mskbits:0x%x, line:%u, argc=%d, argv:%s\n",\
			u->struct_p[3], u->cmd_mskbits, __LINE__, argc, *argv);
	*/
	rc = subcmd(rip_auth_um_table, &u->cmd_mskbits, argc, argv, u);

	/*处理上面subcmd带出来的内层参数， 这里重点是
	enpassw.salt  enpassw.mode  enpassw.passw  enpassw.master_key*/
	if(rc == 0 )
	{
		struct dynamic_key_list_ *key = NULL;
		int pwd_len = 0;
		uint8 keyid = 0;

		keyid = u->struct_p[2];
		/*按照rip的不同认证类型，在这里分别处理*/
	 	switch(u->struct_p[4])
		{
		case RIP_AUTH_PWD_SIM:
			rif->md5_keyid = 0;
			rif->um_mode_sim = enpassw->mode;	/*Fengsb 存的是um的类型0,2,5,6,7,9等值*/
			memset( (char *)rif->simple_key, 0, RIP_AUTH_SIM_LEN);
			memcpy( (char *)rif->simple_key, (char*)enpassw->passw, RIP_AUTH_SIM_LEN);
			switch(enpassw->mode)
			{
				case UM_AUTH_MODE0:
				case UM_AUTH_MODE7:
					break;
#if defined(KOREA_8595) || defined(INCLUDE_HANTECH)
				case UM_AUTH_MODE2:
				case UM_AUTH_MODE5:
				case UM_AUTH_MODE6:
				case UM_AUTH_MODE9:
					rif->saltid_sim = enpassw->salt;
					strncpy(rif->aes_key_sim,enpassw->master_key,AES_ARRY_SZ);
					break;
#endif
				default:
					break;
			}			
			break;
		case RIP_AUTH_PWD_MD5:
			/*Set md5 key_id*/			
			rif->md5_keyid = keyid;
			rif->um_mode_md5 = enpassw->mode;	/*Fengsb 存的是um的类型0,2,5,6,7,9等值*/
			memset( (char *)rif->md5_key, 0, RIP_AUTH_MD5_LEN);
			memcpy( (char *)rif->md5_key, (char*)enpassw->passw, RIP_AUTH_MD5_LEN);
			switch(enpassw->mode)
			{
				case UM_AUTH_MODE0:
				case UM_AUTH_MODE7:
					break;
#if defined(KOREA_8595) || defined(INCLUDE_HANTECH)
				case UM_AUTH_MODE2:
				case UM_AUTH_MODE5:
				case UM_AUTH_MODE6:
				case UM_AUTH_MODE9:
					rif->saltid_md5 = enpassw->salt;
					strncpy(rif->aes_key_md5,enpassw->master_key,AES_ARRY_SZ);
					break;
#endif
				default:
					break;
			}

			break;

		case RIP_AUTH_PWD_DYNC_MD5:
		case RIP_AUTH_PWD_DYNC_SHA1:
			if(u->struct_p[4] == RIP_AUTH_PWD_DYNC_MD5)
				pwd_len = RIP_AUTH_MD5_LEN;
			else
				pwd_len = RIP_AUTH_SHA1_LEN;

			key = rip_neighb_lookup_key(device_index,keyid, 0);
			if(key)
			{
				key->um_mode = enpassw->mode;	/*Fengsb 存的是um的类型0,2,5,6,7,9等值*/
				memcpy( (char *)key->key, (char*)enpassw->passw, pwd_len);
			}
			switch(enpassw->mode)
			{
				case UM_AUTH_MODE0:
				case UM_AUTH_MODE7:
					break;
#if defined(KOREA_8595) || defined(INCLUDE_HANTECH)
				case UM_AUTH_MODE2:
				case UM_AUTH_MODE5:
				case UM_AUTH_MODE6:
				case UM_AUTH_MODE9:
					key->saltid = enpassw->salt;
					strncpy(key->aes_key,enpassw->master_key,AES_ARRY_SZ);
					break;
#endif
				default:
					break;
			}
	
			break;
		}		
	}

	if(enpassw)
	{
		sys_mem_free(enpassw);
	}
	return rc;
}
```

#### rip_auth_um_table

```c
Switch_config_v8#ip rip dynamic-key 1 sha1 2024-12-09-11:30 06:00 ?
  0     -- Specifies plain password for privacy procotol
  7     -- Specifies an encry password for privacy procotol
  WORD  -- The UNENCRYPTED <cleartext> user password
      
Router_config_g0/0#ip rip dynamic-key 1 sha1 aaa 2024-12-09-12:00 06:00 ?
  <cr>
```



```c
struct cmds rip_auth_um_table[] =
{    
#if defined(KOREA_8595) || defined(INCLUDE_HANTECH)
    {
        "2", MATCH_AMB, cmdPriv(0, 0, PV_MAX, 0), UM_ENCRY_SHA256_2,
        rip_auth_um_mode, NULL, NULL, 0, 0,
        "2               -- User plain password used for the SHA256 encrypt",
        "2               -- 输入SHA256加密的明文密码",
        NULLCHAR, NULLCHAR
    },
    {
        "6", MATCH_AMB, cmdPriv(0, 0, PV_MAX, 0), UM_DECRY_SHA256_6,
        rip_auth_um_mode, NULL, NULL, 0, 0,
        NULLCHAR,
        NULLCHAR,
        NULLCHAR, NULLCHAR
    },
    {
        "5", MATCH_AMB, cmdPriv(0, 0, PV_MAX, 0), UM_ENCRY_AES256_5,
        rip_auth_um_mode, NULL, NULL, 0, 0,
        "5               -- User plain password used for the AES256 encrypt",
        "5               -- 输入AES256加密的明文密码",
        NULLCHAR, NULLCHAR
    },
    {
        "9", MATCH_AMB, cmdPriv(0, 0, PV_MAX, 0), UM_DECRY_AES256_9,
        rip_auth_um_mode, NULL, NULL, 0, 0,
        NULLCHAR,
        NULLCHAR,
        NULLCHAR, NULLCHAR
    },
#else
	{
		"0", MATCH_AMB, cmdPriv(0, 0, PV_MAX, 0), UM_UNENCRY_0,
		rip_auth_um_mode, NULL, NULL, 0, 0,
		"0				 -- Specifies plain password for privacy procotol",
		"0				 -- 输入没有加密的明文密码",
		NULLCHAR, NULLCHAR
	},
	{
		"7", MATCH_AMB, cmdPriv(0, 0, PV_MAX, 0), UM_DECRY_7,
		rip_auth_um_mode, NULL, NULL, 0, 0,
		"7				 -- Specifies an encry password for privacy procotol",
		"7				 -- 输入加密后的加密密码密文",
		NULLCHAR, NULLCHAR
	},
	{
		"WORD", MATCH_STR, cmdPriv(0, 0, PV_MAX, 0), UM_UNHIDE_UNENCRY_PWD,
		rip_auth_um_mode, NULL, NULL, 0, 0,
		"WORD			 -- The UNENCRYPTED <cleartext> user password",
		"WORD			 -- 输入没有加密的用户密码明文",
		NULLCHAR, NULLCHAR
	},
	{ "<cr>", MATCH_END, cmdPref(PF_CMDNO, 0, PF_NOCMDNOR), 0,
		NULL, NULL, NULL, 
		0, 0,
		"<cr>",
		"<cr>",
		NULLCHAR, NULLCHAR
	},
#endif
    { NULLCHAR }
};
```



```c
static int rip_auth_um_mode(int argc, char *argv[], struct user *u)
{		
	int rc = 0, i;
	UINT32 mode, pwd_MaxLen = RIP_AUTH_SIM_LEN;	
	union vty_input_attribute param;
	RT_UM_AUTH_INFO *enpassw = (RT_UM_AUTH_INFO *)u->struct_p[5];
	char pwd_new[MAX_USER_INFO] = {0};
	char pwd_renew[MAX_USER_INFO] = {0};
	char *pch = NULL, *str=NULL;

	/*u->struct_p[2]用于存储最终传给rip认证处理函数的UM参数，现在用来存放RT_UM_AUTH_INFO，可以携带更多信息；
	u->cmd_mskbits掩码在每次调用了对应子命令以后，会被LIBCMD模块，将对应子命令的掩码位reset */
	mode = u->struct_p[3] - u->cmd_mskbits;
	if (mode == UM_UNHIDE_UNENCRY_PWD)
	{	/*只有在非韩国模式下，才可能进入此分支，用于命令输入完毕以后，附加? ，会输出<cr>提示*/
	    rc = cmdend(argc - 1, argv + 1, u);
		if (rc != 0) 
		{
			return rc;
		}
		
		/* 表示UM模式0下， CLI输入时，外层命令带掩码UM_UNHIDE_UNENCRY的不是子命令，而是命令参数，所以这里需要
		调整argc和argv*/
		argc++;
		argv--;
	}
	else
	{
		/*暂存UM的类型，可能用于没有配置service password-encryption, service password-hidden时，
		此时在端口下配置ip rip md5 1 md5 7或者0 password的情况下做进一步处理*/
		u->struct_p[6] = mode;
	}

	/*
	Print("RIP: rip_auth_um_mode: line:%d argc = %d, *argv=%s onfig_complete:%d, hidden_flag:%d, MSU_ACTIVE:%d\n",\
		__LINE__, argc, *argv, vty_startup_config_complete, passw_hidden_flag, redn_msu_is_active());
	
	Print("RIP:auth_un_mode: u->struct_p[3]:0x%x, u->cmd_mskbits:0x%x  mode:0x%x line:%u, argc=%d, argv:%s\n",\
		u->struct_p[3], u->cmd_mskbits, mode, __LINE__, argc, *argv);
	*/	
	

	switch(u->struct_p[4])
	{/*不同认证情况下的明文字符长度*/
	case RIP_AUTH_PWD_SIM:
		pwd_MaxLen = RIP_AUTH_SIM_LEN;
		break;
	case RIP_AUTH_PWD_MD5:
	case RIP_AUTH_PWD_DYNC_MD5:
		pwd_MaxLen = RIP_AUTH_MD5_LEN;
		break;
	case RIP_AUTH_PWD_DYNC_SHA1:
		pwd_MaxLen = RIP_AUTH_SHA1_LEN;
		break;
	default:
		syslog(LOG_WARNING, "RIP: rip_auth_um_mode,struct_p[4]=%d, wrong!\n", u->struct_p[4]);
		rc = -1;
		break;
	}
	
	if (rc != 0) 
		return rc;

	if(vty_startup_config_complete && passw_hidden_flag && redn_msu_is_active())
	{	/*表示启动设备，配置已经完成了读取并且本地为活跃主， 命令需要隐藏的情况下，
	    只可能是5，7，9这类情况，则后续进入交互式输入，所以本级已经到命令尾部*/		
		rc = cmdend(argc - 1, argv + 1, u);
		if (rc != 0) 
		{
			return rc;
		}		

		/* u->linebuf就是CLI输入的字符串
			for循环表示类似  端口下输入 "ip ospf password 2 加后面可能存在的一堆空格 "
		   去掉参数后面的空格用来适配logging command, 让后面的通过CMD_HIDE_SUBCMD可以变为ip ospf password 2 *******
		 */		
		for(i = strlen(u->linebuf)-1; i > 0 && u->linebuf[i] == ' '; i-- );
    		u->linebuf[i+1] = '\0';

		/*这里修改UMmode， 并存入cli的命令行参数中，为同步到备控做准备*/
		if(mode == UM_ENCRY_SHA256_2)
			u->linebuf[i] = '6';
		if(mode == UM_ENCRY_AES256_5)
			u->linebuf[i] = '9';

		vty_output(" Please input password(max char nums:%d):", pwd_MaxLen);
	
		/* passwd: no echo */
		param.no_echo_mode = VTY_NO_ECHO_MODE_EDIT;
		vty_input_ctrl(VTY_INPUT_DISABLE_ECHO, &param);
		
		/*read from input*/
		*pwd_new = '\0';
		pch 	  = NULL;
		while (NULL == pch)
			pch = gets(pwd_new);

		rc=strlen(pch);
		vty_input_ctrl(VTY_INPUT_ENABLE_ECHO, NULL);
		for(i=0;i<rc;i++)
		{
			if(pch[i]==32 || pch[i]==34)/* 空格和双引号 */
			{
				vty_output("\n password should not include space or double quotation marks\n");
				return -1;
			}
		}
		if(rc<1)
		{
			vty_output("\n Please input the password(max char nums:%d)!\n", pwd_MaxLen);
			return -1;
		}
		if(rc> pwd_MaxLen)
		{/*限制长度为MD5规定的明文字符数16 */
			vty_output("\n RIP: Password too long!\n");
			return -1;
		}
		vty_output("\n Please input the password AGAIN:");
		vty_input_ctrl(VTY_INPUT_DISABLE_ECHO, &param);
		/*read from input*/
		*pwd_renew = '\0';
		pch 	  = NULL;
		while (NULL == pch)
			pch = gets(pwd_renew);

		/* 校验两次输入的密码是否一致 */
		vty_input_ctrl(VTY_INPUT_ENABLE_ECHO, NULL);
		if (0 != strcmp(pwd_new, pwd_renew))
		{
			vty_output("\n The two passwords are different!\n\n");
			return -1;
		}

		/* 对pwd_new的加工处理， 包括保存到enpassw中，以及加密以后填充到u->linebuf，以同步到备控*/
		str = pwd_new;

		/* resume echo */
		vty_output("\n");

		if (mode == UM_DECRY_7)
		{
			str = um_pass_string_crypt2plain(str);
			if(str == NULL)
			{
				vty_output("RIP:Error encrypt password\n");
				return -1;
			}
			enpassw->mode = 7;
		}
		else if (mode == UM_UNENCRY_0)
		{
			enpassw->mode = UM_AUTH_MODE0;	
		}			
		else if (mode == UM_ENCRY_SHA256_2)
		{
			enpassw->mode = UM_AUTH_MODE2;
		}
		else if (mode == UM_ENCRY_AES256_5)
		{
			enpassw->mode = UM_AUTH_MODE5;
		}
		memcpy(enpassw->passw, str, strlen(str) +1);
#if defined(KOREA_8595) || defined(INCLUDE_HANTECH)
		/*以下两个变量设置初始值，最后要和本地ospf存储的相应数据结构比对；如果本地没有配置同样的密码
		做为新密码，则需要拷贝这两个值，以确保主控和备控的salt值一直。
		也就值为0时，UM会对其赋值，值不为0时，UM则以此值做为判断依据，进行原始密码反算以及查找*/
		memset(enpassw->master_key, 0, AES_ARRY_SZ);
		enpassw->salt = 0;		

		/*返回值str是已经UM加密过的密文字符串，需要同步到备控。也就是备控命令执行的将是密文字符串*/
		str = um_general_encrypt_string(&enpassw->salt, enpassw->master_key, enpassw->mode, str);
#endif
		strcat(u->linebuf," ");
		strcat(u->linebuf,str);
		*argv = *argv + 1;			/*Fengsb 2022-07-17, um模块的do_password_mode函数中，这里是*argv + 2， 但是在ospf/rip如果用+2， 备控会异常*/
		/*这里类似于做了以下事情:
		1. switch_config_v1#ip rip password 2 
		2.  Please input password: <不带回显的用户明文password> 
		3.  Please input the password AGAIN:<不带回显的用户明文password> 
		4. 前述代码处理以后，相当于u->linebuf变成了ip rip password 6 XXXXXXXXXXXXXX(表示加密后的密文)
		5. 因为strcat在前面添加了一个空字符串，以及一个加密后的密文str，所以需要做*argv = *argv + 2
		6. 然后调用下面的CMD_HIDE_SUBCMD在syslog-cmd后，记录密码时变成星号
		7. 这里需要注意的是，将一个空字符串做为参数拷贝进u->linebuf， 有何意图? 其实就是增加了一个空格，按理说不会导致(*argv)++
		
		Print("RIP:auth_un_mode:0x%x,line:%u, argc=%d, argv:%s, linebuf:%s\n", \
			mode, __LINE__, argc, *argv, u->linebuf);	此时参数*argv是um mode的值6, argc为2, 也即argc = 2  *argv = "6" 
		*/
		CMD_HIDE_SUBCMD(0, argv, u);

		rc = 0;
	}
	else
	{/*此分支用于处理备控，或者开机读startup-config时的命令执行
	   或者不满足passw_hidden_flag，也就是没有配置service password-encryption
	  在使用了密文的情况下，备控总是同步6, 7, 9这类级别的UM类型加密密文，这时候是允许在6、7、9后面直接跟
	  加密过后的密文的，因为这时候是不需要做密码的人机交互式输入
	  本函数进来以后，因为做了mode == UM_UNHIDE_UNENCRY的判断，调整了argc和argv，所以这里对于0、6、、7、9
	  直接解析其后的加密或者没有加密过的字符串

	   如果是备控，此分支返回非0值，会让libcmd认为主备命令同步失败，将备控将发生重启。*/
		int min_len = 1;
		int max_len = MaxLenPwd;

#if !defined(KOREA_8595) && !defined(INCLUDE_HANTECH)
		/*非韩国应用场景:表示输入了UM类型，但是却又没有传入后续的密码字符串，所有需要再次调用命令进行输入*/
		if (mode != UM_UNHIDE_UNENCRY_PWD)
		{
			/* 调整命令掩码，在输入了um类型以后，只能再现实 WORD子命令 */
			u->struct_p[3] = u->cmd_mskbits = UM_UNHIDE_UNENCRY_PWD;
			return subcmd(rip_auth_um_table, &u->cmd_mskbits, argc, argv, u);
		}
		else
		{
			/*获取当前UM对应的类型标志位*/
			mode = u->struct_p[6];	
			/*Print("RIP: rip_auth_um_mode: line:%d argc = %d, *argv=%s , mode:%d\n", __LINE__, argc, *argv, mode);*/
		}
#endif

		/* 对应命令tab表rip_auth_um_table[]
		 命令对应为 ip rip md5-key 2 md5 6 XXXXXXXXXXX  
		 MD5(16字符的口令)对应的um7加密字符后长度为29字符； sha1(20字符的口令)对应的加密后最长为42字符
		 如果输入ip rip md5-key 2 md5 7，则后面的字符必须为UM加密后的密文字符
		 */
		CMD_HIDE_PARA(argc, argv, u);		
		rc = getstrrc(&str, argc, argv , min_len, max_len, u);
		/* Print("RIP: rip_auth_um_mode: line:%d *str=%s, mode:%d\n", __LINE__, str, mode); */
		switch (rc)
		{
			case ARG_NOERR:
#if !defined(KOREA_8595) && !defined(INCLUDE_HANTECH)
				if(mode == UM_UNENCRY_0)
				{
					enpassw->mode = UM_AUTH_MODE0;
				}
				else if (mode == UM_DECRY_7)
				{
					str = um_pass_string_crypt2plain(str);
					if(str == NULL)
					{
						Print("RIP:Error decrypt password. Line:%d\n", __LINE__);
						rc = -1;
						break;
					}					
					enpassw->mode = UM_AUTH_MODE7;
				}
#else
				if (mode == UM_DECRY_AES256_9)
		        {
		        	enpassw->mode = UM_AUTH_MODE5;
					str = um_pass_string_crypt2plain_bymode(str, NULL, enpassw->master_key);
		        }					
				else if (mode == UM_DECRY_SHA256_6)
				{
		        	enpassw->mode = UM_AUTH_MODE2;
					str = um_pass_string_crypt2plain_bymode(str, &enpassw->salt, NULL);
		        }					
				else if(mode == UM_ENCRY_AES256_5)
				{
					enpassw->mode = UM_AUTH_MODE5;
					memset(enpassw->master_key, 0, AES_ARRY_SZ);
					um_general_encrypt_string(&enpassw->salt, enpassw->master_key, enpassw->mode, str);
				}
				else if(mode == UM_ENCRY_SHA256_2)
				{
					enpassw->mode = UM_AUTH_MODE2;
					enpassw->salt = 0;
					um_general_encrypt_string(&enpassw->salt, enpassw->master_key, enpassw->mode, str);
				}
#endif
				if(!str)
				{
					Print("RIP:Error encrypt password\n");
					rc = -1;
				}
				else if(strlen(str) > pwd_MaxLen)
				{
					vty_output("RIP: Password too long!\n");
					rc = -1;
				}
				else
				{
					memcpy(enpassw->passw, str, strlen(str) + 1);	
				}
				break;
			default:
				break;
		}
	}

	/* Print("RIP:auth_un_mode,line:%u, rc=%d , password:%s\n", __LINE__, rc, enpassw->passw); */
	return rc;
}
```

#### RT_um_auth_info

```c
typedef struct RT_um_auth_info
{
	UINT32 flag;			/*当前状态，已经存在PWD_EXIST,  新传入的PWD_NEW， 做为返回值使用*/
	char passw[MaxLenPwd+1];/*保存加密时的明文密码*/	
	UINT32 salt;			/*盐值，mode 6时需要这个值; 值为0时，UM会为其分配一个值；
							  非零时，UM以这个值做为密文反算明文的依据以挤保相同盐值，相同明文，算出的密文是一致的							 	*/
	UINT8 mode;				 /* um当前使用的加密模式, 0,7; 2,6; 5,9*/
   	char master_key[AES_ARRY_SZ];	/* mode 9时需要这个值*/
}RT_UM_AUTH_INFO;
```



### cksum函数

#### rt_md5_cksum

```c
void rt_md5_cksum(void *data, unsigned int datalen, unsigned int totallen, void *digest, uint32 *init);
```

#### rip_sha1_cksum

```c
void rip_sha1_cksum(void_t data, size_t datalen, size_t totallen, void_t digest, uint32 * init);
```



```c
void rip_hmac_md5_cksum(void_t data, size_t datalen, size_t totallen, void_t digest, uint32 * init);
void rip_hmac_sha1_cksum(void_t data, size_t datalen, size_t totallen, void_t digest, uint32 * init);
void rip_hmac_sha256_cksum(void_t data, size_t datalen, size_t totallen, void_t digest, uint32 * init);
```





```cmd
[Huawei] keychain key-chain-name 
[Huawei-keychain-keychain-name] key-id 1 
[Huawei-keychain-keychain-name-key-1] cipher-text YOUR_KEY_STRING
[Huawei-keychain-keychain-name-key-1] mode hmac-sha256

[Huawei] interface GigabitEthernet0/0/1 
[Huawei-GigabitEthernet0/0/1] rip authentication-mode hmac-sha256 
[Huawei-GigabitEthernet0/0/1] rip authentication-mode keychain key-chain-name
```

