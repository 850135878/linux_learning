# C语言

## 基础知识

### const相关

#### 1.指针常量和常量指针

- 指针常量

  const修饰的是指针所指向的值，指针的指向可以改变，指针指向的值不可改变。`int const *p`或`const int *p`

- 常量指针

​	const修饰的是指针变量，指针的指向不可改变，指针指向的值可以改变。`int* const p`

#### 2.常量赋值

- 可以使用非const和const数据的地址，赋值给指针常量，<font color='red'>即不可通过指针改变其值。</font>

```c
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
const double locked[4] = {0.08, 0.075, 0.0725, 0.07};
const double *pc = rates; // 有效
pc = locked; //有效
pc = &rates[3]; //有效
```

- 只能把非const数据的地址赋给普通指针。否则，通过指针就能改变const数组中的数据。

```c
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
const double locked[4] = {0.08, 0.075, 0.0725, 0.07};
double * pnc = rates; // 有效
pnc = locked; // 无效
pnc = &rates[3]; // 有效
```

```
int x = 20;
const int y = 23;
int *p1 = &x;
const int *p2 = &y;
const int **pp2; // 指向指针的指针，而这个指针所指向的指针最终指向一个const int类型的值
p1 = p2; // 不安全 -- 把const指针赋给非const指针
p2 = p1; // 有效 -- 把非const指针赋给const指针，前提：只进行一级解引用
pp2 = &p1; // 不安全 –- 嵌套指针类型赋值，进行两级解引用时，这样的赋值也不安全，
```

例如：

```
const int **pp2;
int *p1;
const int n = 13;
pp2 = &p1; // 允许，但是这导致const限定符失效（根据第1行代码，不能通过*pp2修改它所指向的内容）

// *pp2（即 p1）是一个int *类型的变量， C语言允许从const int*到int*的隐式转换，
//但这里实际上是反过来的——你正在尝试将一个const int* 类型的值赋给一个int*类型的变量。
//然而，由于赋值是通过指针的指针进行的，编译器实际上会允许这种操作，但 p1 现在指向了一个 
//const int 类型的对象。
*pp2 = &n; // 有效，两者都声明为const，但是这将导致p1指向n（*pp2已被修改）
*p1 = 10;//有效，但是这将改变n的值（但是根据第3行代码，不能修改n的值）
```



## 数组和指针

### 1.数组初始化

#### 1.部分初始化

如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾值；

但是，如果部分初始化数组，剩余的元素就会被初始化为0。

```c
// 1.不初始化数组  通过下标进行访问时，得到的是随机生成的值
int　some_data[SIZE];


// 2.采用部分初始化
//   剩下的其他元素被初始化为0
int　some_data[SIZE]　=　{1492,　1066};
```

#### 2.指定初始化器（C99）

初始化数组中指定位置的元素。

```c
int arr[6] = {0,0,0,0,0,212}; // 传统的语法
int arr[6] = {[5] = 212};     // C99写法

// 初始化数组中索引为4的元素  如果指定[4] = 20,31,23   那么会将索引4后面的元素都会依次被初始化
#define MONTHS 12
int days[MONTHS] = { 31, 28, [4] = 31, 30, 31, [1] = 29 }; // 31 29 0 0 31 30 31 0 0 0 ...
```



int stuff[] = {1, [6] = 23}; //会发生什么？  

int staff[] = {1, [6] = 4, 9, 10}; //会发生什么？

```txt
编译器会把数组的大小设置为足够装得下初始化的值。所以，stuff数组有7个元素，编号为0～6；而staff数组的元素比stuff数组多两个（即有9个元素）。
```



#### 3.指定数组的大小

> 在C99标准之前，声明数组时<font color='wildstrawberry'>只能在方括号中使用整型常量表达式</font>。所谓整型常量表达式，是由整型常量构成的表达式。

```c
float a1[5];        // 可以
float a2[5*2 + 1];  //可以
float a3[sizeof(int) + 1]; //可以
float a4[-4]; // 不可以，数组大小必须大于0
float a5[0];  // 不可以，数组大小必须大于0
float a6[2.5]; // 不可以，数组大小必须是整数
float a7[(int)2.5]; // 可以，已被强制转换为整型常量

int n = 10;
float a8[n]; // C99之前不允许   变长数组
```



### 2.多维数组

#### 1.二维数组

##### 1.初始化

- 使用两层花括号
- 只保留最外面的一对花括号

![image-20240726153406594](D:\typora笔记\linux_learning\c语言\C语言.assets\image-20240726153406594.png)

```c
int arr[3][4];   // 声明一个指向该数组的指针  int (*p)[4];
//等价于
// 格式一: arr3x4
typedef int arr4[4];     // arr4是一个包含4个整型的数组
typedef arr4 arr3x4[3];  // arr3x4是一个包含3个arr4的数组

// 格式二  形参
int arr[][4]    // 声明一个指向N维数组的指针时，只能省略最左边方括号的值
// 第1对方括号只用于表明这是一个指针,而其他的方括号则用于描述指针所指向数据对象的类型
```



### 3.指针和多维数组

```c
// 数组名zippo是该数组首元素的地址，是这个内含两个int值的数组的地址。
int zippo[4][2]; 

// 三者值相同
zippo = &zippo[0] = &zippo[0][0];
```



#### 1.指向多维数组的指针

```c
int arr[3][4];   // 声明一个指向该数组的指针  int (*p)[4];
//等价于
// 格式一: arr3x4
typedef int arr4[4];     // arr4是一个包含4个整型的数组
typedef arr4 arr3x4[3];  // arr3x4是一个包含3个arr4的数组

// 格式二  形参
int arr[][4]    // 声明一个指向N维数组的指针时，只能省略最左边方括号的值
// 第1对方括号只用于表明这是一个指针,而其他的方括号则用于描述指针所指向数据对象的类型
```



#### 2.指针的兼容性

```
int n = 5;
double x;

int *p1 = &n;
double * pd = &x;

x = n; // 隐式类型转换   int => double
pd = p1; // 编译时错误   int* => double*

int *pt;       // pt指向一个int类型值
int (*pa)[3];  // pa指向一个含3个int类型元素的数组
int ar1[2][3]; // ar1指向一个内含3个int类型元素的数组
int ar2[3][2]; // ar2指向一个内含2个int类型元素的数组
int **p2;      // p2指向一个指针

pt = &ar1[0][0]; // 都是指向int的指针
pt = ar1[0]; // 都是指向int的指针
pt = ar1; // 无效   
pa = ar1; // 都是指向内含3个int类型元素数组的指针
pa = ar2; // 无效
p2 = &pt; // both pointer-to-int *
*p2 = ar2[0]; // 都是指向int的指针
p2 = ar2; // 无效   涉及的两个指针都是指向不同的类型
```















## c语言中的一些未定义错误

编译器在编译时不会检查未定义错误。

- 数据下标越界





格式化输出

```c
%6d   /*按照十进制整型数输出，至少6个字符宽*/
%6f   /*按照浮点数打印，至少6个字符宽*/
%.2f  /*小数点后面2位小数*/
%6.2f /*至少6个字符宽，小数点后有两位小数*/
%.0f  /*强制不打印小数点和小数部分，小数部分位数为0*/
  
%o /*表示八进制数*/
%x /*表示十六进制数*/
%c /*表示字符*/
%s /*表示字符串*/
%% /*表示%本身*/
```

### 字符输入/输出

#### 1.一次读/写一个字符

##### 1.getchar

从文本流中读入下一个输入字符，并将其作为结果值返回。

> c = getchar();

##### 2.putchar

打印一个字符，显示在屏幕上。

> putchar();



#### 2.文件复制

第一版本

```c
int c;
while((ch = getchar()) != EOF){  /* !=的优先级比=高*/
		putchar(c);
}
```



## 数组

### 1.二维数组

```c
int arr[3][4];   // 声明一个指向该数组的指针  int (*p)[4];
//等价于
// 格式一: arr3x4
typedef int arr4[4];     // arr4是一个包含4个整型的数组
typedef arr4 arr3x4[3];  // arr3x4是一个包含3个arr4的数组

// 格式二  形参
int arr[][4]    // 声明一个指向N维数组的指针时，只能省略最左边方括号的值
// 第1对方括号只用于表明这是一个指针,而其他的方括号则用于描述指针所指向数据对象的类型
```

### 2.使用复合字面量给数组赋值（C99）

复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它。

```c
int diva[2] = {10,20};  // 字面常量

// 匿名数组
(int [2]){10,20};   // 复合字面量
(int []){50,20,40}; // 内含3个元素的复合字面量
```

```c
// 2.通过指针来指向复合字面量
int *p;
p = (int [2]){10,20};  

// 二维数组
int (*p2)[4];
p2 = (int [2][4]){{1,2,3,4},{5,6,7,8}};
```

```c
// 3.复合字面量作为实参传递给函数
int sum(const int ar[], int n);
sum((int []){4,4,4,5,5,5}, 6);
```



## 字符串

### 1.字符串是否可修改

```c
char * word = "frame";
word[1] = 'l';   // 不允许，是未定义行为，可能会导致内存访问错误

// 推荐写法
const char* word = "frame";

//原因：编译器可以使用内存中的一个副本来表示所有完全相同的字符串字面量。
// 编译器可以用相同的地址替换每个"I'm special"实例
// 如果编译器使用这种单次副本表示法，并允许p1[0]修改'F'，那将影响所有使用该字符串的代码。所以以上语句打印字符串字面量"I'm special"时实际上显示的是"F'm special"：

#define MSG "I'm special"
char ar[] = MSG;
const char *pt = MSG;
printf("address of \"I'm special\": %p \n", "I'm special");  // 0x100000f10
printf("address ar: %p\n", ar);		//0x7fff5fbff858
printf("address pt: %p\n", pt);   //0x100000f10
printf("address of MSG: %p\n", MSG); //0x100000f10
printf("address of \"I'm special\": %p \n", "I'm special");  //0x100000f10
```



### 2.字符串输入/输出

#### 1.gets()/puts() 不建议

gets读取整行，直到读到换行符为止。

> gets()不建议使用。输入的字符串过长，会导致缓冲区溢出;
>
> 如果这些多余的字符只是占用了尚未使用的内存，就不会立即出现问题；如果它们擦写掉程序中的其他数据，会导致程序异常中止；或者还有其他情况。
>
> Segmentation fault：分段错误。程序试图访问了未分配的内存。
>
> 
>
> puts(传入字符串地址):
>
> ​		遇到空字符停止输出，并自动在末尾加上换行符





#### 2.fgets()/fputs() 推荐

fgets()通过第2个参数限制读入的字符数来解决溢出的问题。还有会将读到的\n保存（gets会丢弃）。

puts()会在待输出字符串末尾添加一个换行符，而fputs()不会。

```
// fgets(words, STLEN, stdin):
// 		参数二：指明读入字符的最大数量  若设置n，则最多读入n-1字符，或者读到遇到的第一个换行符为止。
// 		参数三：指明要读入的文件  stdin 从键盘输入

// fputs(words, stdout);
//    参数二：指明它要写入的文件。
//    参数三：设置stdout则输出在屏幕上。
//  返回值：
//		fputs()函数返回指向 char的指针。   不会在末尾加换行符
//			若成功，返回的地址与传入的第1个参数相同。
//			如果函数读到文件结尾，它将返回一个特殊的指针：空指针（null pointer）
```

#### 3.gets_s()

见C11特性

> 如果输入行太长会怎样？
>
> 使用gets()不安全，它会擦写现有数据，存在安全隐患。
>
> gets_s()函数很安全，但是，如果并不希望程序中止或退出，就要知道如何编写特殊的“处理函数”。
>
> 另外，如果打算让程序继续运行，gets_s()会丢弃该输入行的其余字符，无论你是否需要。当输入太长，超过数组可容纳的字符数时，fgets()函数最容易使用，而且可以选择不同的处理方式。如果要让程序继续使用输入行中超出的字符，可以参考程序清单11.8中的处理方法。如果想丢弃输入行的超出字符，可以参考程序清单11.9中的处理方法。

#### 4.自定义s_gets()函数

读取整行输入并用空字符代替换行符，或者读取一部分输入，并丢弃其余部分。

丢弃其余部分：由于输入行中多出来的字符会被留在缓冲区中，会成为下一次读取语句的输入。

```c
char * s_gets(char * st, int n)
{
		char * ret_val;
		int i = 0;
  	// 返回NULL，读到文件结尾或出现读取错误
		ret_val = fgets(st, n, stdin);
		if (ret_val) // 即ret_val != NULL  
		{
				while (st[i] != '\n' && st[i] != '\0')
						i++;
				if (st[i] == '\n')
						st[i] = '\0';
				else
            // 如果字符串中出现空字符，就丢弃该输入行的其余字符，然后返回与fgets()相同的值。
						while (getchar() != '\n')
								continue;
		}
		return ret_val;
}
```



#### 5.printf()

printf(传入字符串的地址)不会自动在每个字符串末尾加上一个换行符。







## C99特性

### 1.指定初始化器





### 2.可变长数组

#### 1.定义可变长数组

```c
int arr[m];   // C99之前不允许
int arr[n];   // C99之前不允许

// 通用的指定数组大小
int arr[MAXSIZE];
int arr[10];
int arr[sizeof(int)*2];  // sizeof表达式值为整数常量
int arr[(int)2.5];
int arr[5*2+1];
```

#### 2.带变长数组形参的函数

声明的函数可以处理任意大小的二维数组

```c
// ar是一个指针，指向一个含cols个int类型的值的数组  即data[0]
int sum2d(int rows, int cols, int ar[rows][cols]);

// 错误写法
int sum2d(int ar[rows][cols], int rows, int cols);

// 省略形参名，用*代替
int sum2d(int, int, int ar[*][*]);
```



## C11特性

### 1.gets_s()

去除了C99中的gets()函数。

类似于fgets()： gets_s(words, STLEN);

**与fgets()区别：**

```txt
1、gets_s()只从标准输入中读取数据，只需两个参数。 fgets()第三个参数可以从文件读入
2、如果gets_s()读到换行符，会丢弃它而不是储存它。 fgets()会存储
```

注意：如果gets_s()读到最大字符数都没有读到换行符。

```
1：把目标数组中的首字符设置为空字符，读取并丢弃随后的输入直至读到换行符或文件结尾，
2：然后返回空指针。
3：接着，调用依赖实现的“处理函数”（或你选择的其他函数），可能会中止或退出程序。
```



### 2.多维数组

### 3.



## c语言中的一些未定义错误

编译器在编译时不会检查未定义错误。

- 数据下标越界





格式化输出

```c
%6d   /*按照十进制整型数输出，至少6个字符宽*/
%6f   /*按照浮点数打印，至少6个字符宽*/
%.2f  /*小数点后面2位小数*/
%6.2f /*至少6个字符宽，小数点后有两位小数*/
%.0f  /*强制不打印小数点和小数部分，小数部分位数为0*/
  
%o /*表示八进制数*/
%x /*表示十六进制数*/
%c /*表示字符*/
%s /*表示字符串*/
%% /*表示%本身*/
```

### 字符输入/输出

#### 1.一次读/写一个字符

##### 1.getchar

从文本流中读入下一个输入字符，并将其作为结果值返回。

> c = getchar();

##### 2.putchar

打印一个字符，显示在屏幕上。

> putchar();



#### 2.文件复制

第一版本

```c
int c;
while((ch = getchar()) != EOF){  /* !=的优先级比=高*/
		putchar(c);
}
```



## 数组

### 1.二维数组



### 2.使用复合字面量给数组赋值（C99）

复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它。

```c
int diva[2] = {10,20};  // 字面常量

// 匿名数组
(int [2]){10,20};   // 复合字面量
(int []){50,20,40}; // 内含3个元素的复合字面量
```

```c
// 2.通过指针来指向复合字面量
int *p;
p = (int [2]){10,20};  

// 二维数组
int (*p2)[4];
p2 = (int [2][4]){{1,2,3,4},{5,6,7,8}};
```

```c
// 3.复合字面量作为实参传递给函数
int sum(const int ar[], int n);
sum((int []){4,4,4,5,5,5}, 6);
```



## 字符串

### 1.字符串是否可修改

```c
char * word = "frame";
word[1] = 'l';   // 不允许，是未定义行为，可能会导致内存访问错误

// 推荐写法
const char* word = "frame";

//原因：编译器可以使用内存中的一个副本来表示所有完全相同的字符串字面量。
// 编译器可以用相同的地址替换每个"I'm special"实例
// 如果编译器使用这种单次副本表示法，并允许p1[0]修改'F'，那将影响所有使用该字符串的代码。所以以上语句打印字符串字面量"I'm special"时实际上显示的是"F'm special"：

#define MSG "I'm special"
char ar[] = MSG;
const char *pt = MSG;
printf("address of \"I'm special\": %p \n", "I'm special");  // 0x100000f10
printf("address ar: %p\n", ar);		//0x7fff5fbff858
printf("address pt: %p\n", pt);   //0x100000f10
printf("address of MSG: %p\n", MSG); //0x100000f10
printf("address of \"I'm special\": %p \n", "I'm special");  //0x100000f10
```



### 2.字符串输入/输出

#### 1.gets()/puts() 不建议

gets读取整行，直到读到换行符为止。

> gets()不建议使用。输入的字符串过长，会导致缓冲区溢出;
>
> 如果这些多余的字符只是占用了尚未使用的内存，就不会立即出现问题；如果它们擦写掉程序中的其他数据，会导致程序异常中止；或者还有其他情况。
>
> Segmentation fault：分段错误。程序试图访问了未分配的内存。
>
> 
>
> puts(传入字符串地址):
>
> ​		遇到空字符停止输出，并自动在末尾加上换行符





#### 2.fgets()/fputs() 推荐

fgets()通过第2个参数限制读入的字符数来解决溢出的问题。还有会将读到的\n保存（gets会丢弃）。

puts()会在待输出字符串末尾添加一个换行符，而fputs()不会。

```
// fgets(words, STLEN, stdin):
// 		参数二：指明读入字符的最大数量  若设置n，则最多读入n-1字符，或者读到遇到的第一个换行符为止。
// 		参数三：指明要读入的文件  stdin 从键盘输入

// fputs(words, stdout);
//    参数二：指明它要写入的文件。
//    参数三：设置stdout则输出在屏幕上。
//  返回值：
//		fputs()函数返回指向 char的指针。   不会在末尾加换行符
//			若成功，返回的地址与传入的第1个参数相同。
//			如果函数读到文件结尾，它将返回一个特殊的指针：空指针（null pointer）
```

#### 3.gets_s()

见C11特性

> 如果输入行太长会怎样？
>
> 使用gets()不安全，它会擦写现有数据，存在安全隐患。
>
> gets_s()函数很安全，但是，如果并不希望程序中止或退出，就要知道如何编写特殊的“处理函数”。
>
> 另外，如果打算让程序继续运行，gets_s()会丢弃该输入行的其余字符，无论你是否需要。当输入太长，超过数组可容纳的字符数时，fgets()函数最容易使用，而且可以选择不同的处理方式。如果要让程序继续使用输入行中超出的字符，可以参考程序清单11.8中的处理方法。如果想丢弃输入行的超出字符，可以参考程序清单11.9中的处理方法。

#### 4.自定义s_gets()函数

读取整行输入并用空字符代替换行符，或者读取一部分输入，并丢弃其余部分。

丢弃其余部分：由于输入行中多出来的字符会被留在缓冲区中，会成为下一次读取语句的输入。

```c
char * s_gets(char * st, int n)
{
		char * ret_val;
		int i = 0;
  	// 返回NULL，读到文件结尾或出现读取错误
		ret_val = fgets(st, n, stdin);
		if (ret_val) // 即ret_val != NULL  
		{
				while (st[i] != '\n' && st[i] != '\0')
						i++;
				if (st[i] == '\n')
						st[i] = '\0';
				else
            // 如果字符串中出现空字符，就丢弃该输入行的其余字符，然后返回与fgets()相同的值。
						while (getchar() != '\n')
								continue;
		}
		return ret_val;
}
```



#### 5.printf()

printf(传入字符串的地址)不会自动在每个字符串末尾加上一个换行符。







## C99特性

### 1.指定初始化器

初始化数组中指定位置的元素。

```c
int arr[6] = {0,0,0,0,0,212}; // 传统的语法
int arr[6] = {[5] = 212};     // C99写法

// 初始化数组中索引为4的元素
#define MONTHS 12
int days[MONTHS] = { 31, 28, [4] = 31, 30, 31, [1] = 29 }; // 31 29 0 0 31 30 31 0 0 0 ...
```

如果指定[4] = 20,31,23   那么会将索引4后面的元素都会依次被初始化



### 2.可变长数组

#### 1.定义可变长数组

```c
int arr[m];   // C99之前不允许
int arr[n];   // C99之前不允许

// 通用的指定数组大小
int arr[MAXSIZE];
int arr[10];
int arr[sizeof(int)*2];  // sizeof表达式值为整数常量
int arr[(int)2.5];
int arr[5*2+1];
```

#### 2.带变长数组形参的函数

声明的函数可以处理任意大小的二维数组

```c
// ar是一个指针，指向一个含cols个int类型的值的数组  即data[0]
int sum2d(int rows, int cols, int ar[rows][cols]);

// 错误写法
int sum2d(int ar[rows][cols], int rows, int cols);

// 省略形参名，用*代替
int sum2d(int, int, int ar[*][*]);
```



## C11特性

### 1.gets_s()

去除了C99中的gets()函数。

类似于fgets()： gets_s(words, STLEN);

**与fgets()区别：**

```txt
1、gets_s()只从标准输入中读取数据，只需两个参数。 fgets()第三个参数可以从文件读入
2、如果gets_s()读到换行符，会丢弃它而不是储存它。 fgets()会存储
```

注意：如果gets_s()读到最大字符数都没有读到换行符。

```
1：把目标数组中的首字符设置为空字符，读取并丢弃随后的输入直至读到换行符或文件结尾，
2：然后返回空指针。
3：接着，调用依赖实现的“处理函数”（或你选择的其他函数），可能会中止或退出程序。
```



## C语言踩坑事项

### 1.编译器不会检查数组下标越界

在C标准中，使用越界下标的结果是未定义的。

### 2.函数原型可以省略参数名，函数定义时不能省略

```
// 四种方式等价
int sum(int *ar, int n);
int sum(int *, int);
int sum(int ar[], int n);
int sum(int [], int);
```

### 3.运算符优先级

```
* ++ //优先级一样，结合律从右往左
```

### 4.C11/C99不允许将不同类型的地址相互强转为其他指针类型

```
不允许将double类型的地址赋给指向int的指针  
```

### 5.编译器不会检查指针是否仍指向数组元素

C 只能保证指向数组任意元素的指针和**<font color='wildstrawberry'>指向数组后面第 1 个位置的指针</font>**有效。

但是，如果递增或递减一个指针后超出了这个范围，则是未定义的。

### 6.不能解引用未初始化的指针

创建一个指针时，<font color='red'>系统只分配了储存指针本身的内存，并未分配储存数据的内存</font>。因此，在使用指针之前，必须先用已分配的地址初始化它。

### 7.C++不允许把const指针赋给非const指针。而C则允许这样做

```
const int y;
const int * p2 = &y;
int *p1;
p1 = p2; // C++中不允许这样做，但是C可能只给出警告
```

但是如果通过p1更改y，其行为是未定义的.







